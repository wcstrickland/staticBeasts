<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demilich</title>
</head>
    <body>
        <div class="post">
  <div class="stat-block">
    <hr class="orange-border"/>
    <div class="section-left">
      <div class="creature-heading">
        <div style="display:flex; justify-content:space-between;">
          <h1>Demilich</h1>
        </div>
        <h2 style="color:black;">T, Neutral Evil</h2>
      </div>
      <!-- creature heading -->
      <svg height="5" width="100%" class="tapered-rule">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div class="top-stats">
  <!-- property line -->
  <div class="property-line">
    <h4>Hit Points</h4>
    <div >
      <input type="text" style="width:2em;" value=80 (20d4)></input>
      <p>80 (20d4)</p>
    </div>
  </div>
  <!-- property line -->
  <div class="property-line first">
    <h4>Armor Class:</h4>
    <p>20 (natural armor)</p>
  </div>
  <div class="property-line last">
    <h4>Speed:</h4>
    <p>walk 0 ft., fly 30 ft.</p>
  </div>
  <!-- property line -->
  <svg height="5" width="100%" class="tapered-rule">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  <div class="abilities">
    <div>
      <div class="stat-header">
        <b class="stat-value">STR</b>
      </div>
      1 -5
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">DEX</b>
      </div>
      20 <a class='roll'>+5</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CON</b>
      </div>
      10 <a class='roll'>+0</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">WIS</b>
      </div>
      17 <a class='roll'>+3</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">INT</b>
      </div>
      20 <a class='roll'>+5</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CHA</b>
      </div>
      20 <a class='roll'>+5</a>
    </div>
  </div>
  <svg height="5" width="100%" class="tapered-rule top-gap">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  
    <div class="property-line">
      <h4>Damage Immunities:</h4>
      <p>necrotic, poison, psychic; bludgeoning, piercing, slashing from nonmagical attacks</p>
    </div>
    

    
      <div class="property-line">
        <h4>Damage Resistances:</h4>
        <p>bludgeoning, piercing, slashing from magic weapons</p>
      </div>
      

      

        
          <div class="property-line">
            <h4>Condition Immunities:</h4>
            <p>charmed, deafened, exhaustion, frightened, paralyzed, petrified, poisoned, prone, stunned</p>
          </div>
          

          
            <div class="property-line">
              <h4>Senses:</h4>
              <p>truesight 120 ft.</p>
            </div>
            

            
              <div class="property-line">
                <h4>Saving Throws:</h4>
                <p>
                  Con <a class='roll'>+6</a>, Int <a class='roll'>+11</a>, Wis <a class='roll'>+9</a>, Cha <a class='roll'>+11</a>
                </p>
              </div>
              

              

                

                  

                    
                      <div class="property-line">
                        <h4>Challenge:</h4>
                        <p>18</p>
                      </div>
                      

                      

                      </div>
      <svg height="5" width="100%" class="tapered-rule bottom-gap">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div id="actions">
    
        <div class="creature-heading">
            <h1>Traits</h1>
        </div>
        <div>
            
                <div>
                    <b>Avoidance: </b>
                    <span>If the demilich is subjected to an effect that allows it to make a saving throw to take only half damage, it instead takes no damage if it succeeds on the saving throw, and only half damage if it fails.</span>
                </div>
                <br/>
                
                <div>
                    <b>Legendary Resistance (3/Day): </b>
                    <span>If the demilich fails a saving throw, it can choose to succeed instead.</span>
                </div>
                <br/>
                
                <div>
                    <b>Turn Immunity: </b>
                    <span>The demilich is immune to effects that turn undead.</span>
                </div>
                <br/>
                
            </div>
        </div>
        
        
            <div id="actions">
                <div class="creature-heading">
                    <h1>Actions</h1>
                </div>
                <div>
                    
                        <div>
                            <b>Howl (Recharge 5-6): </b>
                            <span>The demilich emits a bloodcurdling howl. Each creature within 30 feet of the demilich that can hear the howl must succeed on a DC 15 Constitution saving throw or drop to 0 hit points. On a successful save, the creature is frightened until the end of its next turn.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Life Drain: </b>
                            <span>The demilich targets up to three creatures that it can see within 10 feet of it. Each target must succeed on a DC 19 Constitution saving throw or take 21 <a class='roll'>(6d6)</a> necrotic damage, and the demilich regains hit points equal to the total damage dealt to all targets.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Variant: Acererak and His Disciples: </b>
                            <span>The transformation into a demilich isn't a bitter end for all liches that experience it. Made as a conscious choice, the path of the demilich becomes the next step in a dark evolution. The lich Acererak—a powerful wizard and demonologist and the infamous master of the Tomb of Horrors—anticipated his own transformation, preparing for it by setting enchanted gemstones into his skull's eye sockets and teeth. Each of these soul gems possessed the power to capture the souls on which his phylactery would feed.,Acererak abandoned his physical body, accepting that it would molder and dissolve to dust while he traveled the planes as a disembodied consciousness. If the skull that was his last physical remains was ever disturbed, its gems would claim the souls of the insolent intruders to his tomb, magically transferring them to his phylactery.,Liches who follow Acererak's path believe that by becoming free of their bodies, they can continue their quest for power beyond the mortal world. As their patron did, they secure their remains within well-guarded vaults, using soul gems to maintain their phylacteries and destroy the adventurers who disturb their lairs.,Acererak or another demilich like him has a challenge rating of 21 (33,000 XP), or 23 (50,000 XP) in its lair, and gains the following additional action option.,Trap Soul. The demilich targets one creature that it can see within 30 feet of it. The target must make a DC 19 Charisma saving throw. On a failed save, the target's soul is magically trapped inside one of the demilich's gems. While the soul is trapped, the target's body and all the equipment it is carrying cease to exist. On a successful save, the target takes 24 (7d6) necrotic damage, and if this damage reduces the target to 0 hit points, its soul is trapped as if it failed the saving throw. A soul trapped in a gem for 24 hours is devoured and ceases to exist.,If the demilich drops to 0 hit points, it is destroyed and turns to powder, leaving behind its gems. Crushing a gem releases any soul trapped within, at which point the target's body re-forms in an unoccupied space nearest to the gem and in the same state as when it was trapped.</span>
                        </div>
                        <br/>
                        
                        <br/>
                    </div>
                </div>
                
                
                        
                            <div id="actions">
                                <div class="creature-heading">
                                    <h1>Legendary Actions</h1>
                                </div>
                                <div>
                                    
                                        <div>
                                            <b>: </b>
                                            <span>The undead can take 4 legendary actions, choosing from the options below. Only one legendary action can be used at a time and only at the end of another creature's turn. The undead regains spent legendary actions at the start of its turn.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Flight: </b>
                                            <span>The demilich flies up to half its flying speed.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Cloud of Dust: </b>
                                            <span>The demilich magically swirls its dusty remains. Each creature within 10 feet of the demilich, including around a corner, must succeed on a DC 15 Constitution saving throw or be blinded until the end of the demilich's next turn. A creature that succeeds on the saving throw is immune to this effect until the end of the demilich's next turn.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Energy Drain (Costs 2 Actions): </b>
                                            <span>Each creature with in 30 feet of the demilich must make a DC 15 Constitution saving throw. On a failed save, the creature's hit point maximum is magically reduced by 10 <a class='roll'>(3d6)</a>. If a creature's hit point maximum is reduced to 0 by this effect, the creature dies. A creature's hit point maximum can be restored with the  greater restoration spell or similar magic.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Vile Curse (Costs 3 Actions): </b>
                                            <span>The demilich targets one creature it can see within 30 feet of it. The target must succeed on a DC 15 Wisdom saving throw or be magically cursed. Until the curse ends, the target has disadvantage on attack rolls and saving throws. The target can repeat the saving throw at the end of each of its turns, ending the curse on a success.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Lair Actions: </b>
                                            <span>On initiative count 20 (losing initiative ties), the demilich rolls a d20. On a result of 11 or higher, the demilich takes a lair action to cause one of the following effects. It can't use the same effect two rounds in a row.,• The tomb trembles violently for a moment. Each creature on the floor of the tomb must succeed on a DC 19 Dexterity saving throw or be knocked prone.,• The demilich targets one creature it can see within 60 feet of it. An antimagic field fills the space of the target, moving with it until initiative count 20 on the next round.,• The demilich targets any number of creatures it can see within 30 feet of it. No target can regain hit points until initiative count 20 on the next round.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Regional Effects: </b>
                                            <span>A demilich's tomb might have any or all of the following effects in place:,• The first time a non-evil creature enters the tomb's area, the creature takes 16 (3d10) necrotic damage.,• Monsters in the tomb have advantage on saving throws against being charmed or frightened, and against features that turn undead.,• The tomb is warded against the magical travel of creatures the demilich hasn't authorized. Such creatures can't teleport into or out of the tomb's area or use planar travel to enter or leave it. Effects that allow teleportation or planar travel work within the tomb as long as they aren't used to leave or enter the tomb's area.,If the demilich is destroyed, these effects fade over the course of 10 days.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                    </div>
                                </div>
                                

      <div id="reactions">
        <div class="creature-heading">
          <h1>
              Description
          </h1>
        </div>
        <p>The immortality granted to a lich lasts only as long as it feeds mortal souls to its phylactery. If it falters or fails in that task, its bones turn to dust until only its skull remains. This "demilich" contains only a fragment of the lich's malevolent life force-just enough so that if it is disturbed, these remains rise into the air and assume a wraith-like form. The skull then emits a terrifying howl that can slay the weak-hearted and leave others trembling with fear. Left alone, it sinks back down and returns to the empty peace of its existence.
Few liches seek to become demiliches, for it means an end to the existence they hoped to preserve by becoming undead. However, time can erode the lich's reason and memory, causing it to retreat into its ancient tomb and forget to feed on souls. The spells it once knew fade from its mind, and it no longer channels the arcane energy it wielded as a lich. However, even as a mere skull it remains a deadly and vexing enemy.
Enduring Existence. Even after a lich is reduced to a demilich state, its phylactery survives. As long as its phylactery is intact, the demilich can't be permanently destroyed. Its skull reforms after 1d10 days, restoring the creature to its wretched state. If it has the presence of mind to do so, a demilich can reclaim its former power by feeding just one soul to its phylactery. Doing so restores the demilich to lich form, reconstituting its undead body.
Undead Nature. A demilich doesn't require air, food, drink, or sleep. So great is a demilich's will to survive that it always has the maximum number of hit points for its Hit Dice, instead of average hit points.
A Demilich's Lair. A demilich hides its earthly remains and treasures in a labyrinthine tomb guarded by monsters and traps. At the heart of this labyrinth rests the demilich's skull and the dust from its other bones. In its crypt, a demilich has access to lair actions and additional uses for its legendary actions. Its whole lair also has unique traits. A demilich in its lair has a challenge rating of 20 (24,500 XP).
Acererak and His Disciples. The transformation into a demilich isn't a bitter end for all liches that experience it. Made as a conscious choice, the path of the demilich becomes the next step in a dark evolution. The lich Acererak-a powerful wizard and demonologist and the infamous master of the Tomb of Horrors-anticipated his own transformation, preparing for it by setting enchanted gemstones into his skull's eye sockets and teeth. Each of these soul gems possessed the power to capture the souls on which his phylactery would feed.
Acererak abandoned his physical body, accepting that it would molder and dissolve to dust while he traveled the planes as a disembodied consciousness. If the skull that was his last physical remains was ever disturbed, its gems would claim the souls of the insolent intruders to his tomb, magically transferring them to his phylactery.
Liches who follow Acererak's path believe that by becoming free of their bodies, they can continue their quest for power beyond the mortal world. As their patron did, they secure their remains within well-guarded vaults, using soul gems to maintain their phylacteries and destroy the adventurers who disturb their lairs.
Acererak or another demilich like him has a challenge rating of 21 (33,000 XP), or 23 (50,000 XP) in its lair, and gains the following additional action option.
Trap Soul. The demilich targets one creature that it can see within 30 feet of it. The target must make a DC 19 Charisma saving throw. On a failed save, the target's soul is magically trapped inside one of the demilich's gems. While the soul is trapped, the target's body and all the equipment it is carrying cease to exist. On a successful save, the target takes 24 (7d6) necrotic damage, and if this damage reduces the target to 0 hit points, its soul is trapped as if it failed the saving throw. A soul trapped in a gem for 24 hours is devoured and ceases to exist.
If the demilich drops to 0 hit points, it is destroyed and turns to powder, leaving behind its gems. Crushing a gem releases any soul trapped within, at which point the target's body re-forms in an unoccupied space nearest to the gem and in the same state as when it was trapped.
Source: Monster Manual p. 48, Tales from the Yawning Portal, Waterdeep: Dungeon of the Mad Mage, Ghosts of Saltmarsh, Explorer's Guide to Wildemount, Icewind Dale: Rime of the Frostmaiden</p>
      </div>
      <hr class="orange-border bottom"/>
    </div>
  </div>
</div>
    </body>
    <script>

    function findToHit(dataString) {
        const pattern = /\+(\d{1,2}) to hit/
        let match = dataString.match(pattern)
        if (match !== null) {
            match = match[1]
        }
        return {
            "exists": match !== null,
            "value": parseInt(match)
        }
    }

    function findDamageStrings(dataString) {
        if (typeof dataString === "string") {
            let damageStrings = []
            // const toHitPattern = /\+(\d{1,2}) to hit/
            const toHitPattern = /\+(\d{1,2})/g
            const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/g
            let damageMatches = dataString.matchAll(damagePattern)
            let toHitMatches = dataString.matchAll(toHitPattern)
            for (let match of toHitMatches) {
                if (toHitMatches !== null) {
                    damageStrings.push(match[0])
                }
            }
            for (let match of damageMatches) {
                if (match !== null) {
                    damageStrings.push(match[0])
                }
            }
            return damageStrings
        }
        return []
    }

    function extractRoll(dataString) {
        const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/
        const toHitPattern = /\+(\d{1,2})/
        let damageMatch = dataString.match(damagePattern)
        let toHitMatch = dataString.match(toHitPattern)
        if (toHitMatch !== null) {
            return {"num": 1, "sides": 20, "mod": toHitMatch[1]}
        }
        if (damageMatch !== null) {
            return {"num": damageMatch[1], "sides": damageMatch[2], "mod": damageMatch[3]}
        }
    }

    function randomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + 1);
    }

    function generateRollText(num, sides, mod) {
        let output = []
        let total = 0
        for (let i = 0; i < num; i++) {
            let roll = randomNumber(1, sides)
            total += roll
            output.push(roll)
            output.push("+")
        }
        output.pop()
        if (mod >= 0 && mod !== "") {
            output.push("+")
            output.push(`(${mod})`)
            total += parseInt(mod) || 0
        } else {
            if (mod !== "") {
                output.push("+")
                output.push(`(${mod})`)
                total += parseInt(mod) || 0
            }
        }
        output.push(` = ${total}`)
        return output.join(" ")
    }

    function splitAroundRoll(dataString, patternMatches) {
        let outPut = []
        let currentPosition = 0
        for (let match of patternMatches) {
            let matchLength = match.length
            let matchStartingPosition = dataString.indexOf(match, currentPosition)
            let matchEndingPosition = matchStartingPosition + matchLength
            outPut.push({
                "value": dataString.slice(currentPosition, matchStartingPosition),
                "replace": false
            })
            currentPosition = matchEndingPosition
            outPut.push({"value": match, "replace": true})
        }
        outPut.push({"value": dataString.slice(currentPosition), "replace": false})
        return outPut;
    }

    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }

    function findSpells(traitText, spell_list) {
        let outPutList = [];
        let wordArray = traitText.split(",")
        for (let word of wordArray) {
            if (word.includes(":")) {
                word = word.slice(word.indexOf(":") + 1)
            }
            if (spell_list.includes(word.trim())) {
                outPutList.push(word)
            }
        }
        return outPutList
    }

    function addSpellIds(chunks, spell_list) {
        for (let chunk of chunks) {
            if (chunk.replace) {
                if (chunk.value.includes(":")) {
                    chunk.value = chunk
                        .value
                        .slice(chunk.value.indexOf(":") + 1)
                }
                chunk["spellId"] = spell_list.indexOf(chunk.value.trim())
            }
        }
        return chunks
    }

    document.addEventListener('DOMContentLoaded', () => {
        document
            .querySelectorAll('.roll')
            .forEach(element => {
                element.addEventListener('click', () => {
                    let roll = extractRoll(element.textContent)
                    let rollText = generateRollText(roll.num, roll.sides, roll.mod);
                    Toastify({
                        text: rollText,
                        duration: 1000,
                        gravity: "bottom", // `top` or `bottom`
                        position: "center", // `left`, `center` or `right`
                        stopOnFocus: true, // Prevents dismissing of toast on hover
                    }).showToast();

                    console.log(rollText)
                });
            });
    });
    (function (root, factory) {
        if (typeof module === "object" && module.exports) {
            module.exports = factory();
        } else {
            root.Toastify = factory();
        }
    })(this, function (global) {
        // Object initialization
        var Toastify = function (options) {
                // Returning a new init object
                return new Toastify
                    .lib
                    .init(options);
            },
            // Library version
            version = "1.12.0";

        // Set the default global options
        Toastify.defaults = {
            oldestFirst: true,
            text: "Toastify is awesome!",
            node: undefined,
            duration: 3000,
            selector: undefined,
            callback: function () {},
            destination: undefined,
            newWindow: false,
            close: false,
            gravity: "toastify-top",
            positionLeft: false,
            position: '',
            backgroundColor: '',
            avatar: "",
            className: "",
            stopOnFocus: true,
            onClick: function () {},
            offset: {
                x: 0,
                y: 0
            },
            escapeMarkup: true,
            ariaLive: 'polite',
            style: {
                background: ''
            }
        };

        // Defining the prototype of the object
        Toastify.lib = Toastify.prototype = {
            toastify: version,

            constructor: Toastify,

            // Initializing the object with required parameters
            init: function (options) {
                // Verifying and validating the input object
                if (!options) {
                    options = {};
                }

                // Creating the options object
                this.options = {};

                this.toastElement = null;

                // Validating the options
                this.options.text = options.text || Toastify.defaults.text; // Display message
                this.options.node = options.node || Toastify.defaults.node; // Display content as node
                this.options.duration = options.duration === 0
                    ? 0
                    : options.duration || Toastify.defaults.duration; // Display duration
                this.options.selector = options.selector || Toastify.defaults.selector; // Parent selector
                this.options.callback = options.callback || Toastify.defaults.callback; // Callback after display
                this.options.destination = options.destination || Toastify.defaults.destination; // On-click destination
                this.options.newWindow = options.newWindow || Toastify.defaults.newWindow; // Open destination in new window
                this.options.close = options.close || Toastify.defaults.close; // Show toast close icon
                this.options.gravity = options.gravity === "bottom"
                    ? "toastify-bottom"
                    : Toastify.defaults.gravity; // toast position - top or bottom
                this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft; // toast position - left or right
                this.options.position = options.position || Toastify.defaults.position; // toast position - left or right
                this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor; // toast background color
                this.options.avatar = options.avatar || Toastify.defaults.avatar; // img element src - url or a path
                this.options.className = options.className || Toastify.defaults.className; // additional class names for the toast
                this.options.stopOnFocus = options.stopOnFocus === undefined
                    ? Toastify.defaults.stopOnFocus
                    : options.stopOnFocus; // stop timeout on focus
                this.options.onClick = options.onClick || Toastify.defaults.onClick; // Callback after click
                this.options.offset = options.offset || Toastify.defaults.offset; // toast offset
                this.options.escapeMarkup = options.escapeMarkup !== undefined
                    ? options.escapeMarkup
                    : Toastify.defaults.escapeMarkup;
                this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
                this.options.style = options.style || Toastify.defaults.style;
                if (options.backgroundColor) {
                    this.options.style.background = options.backgroundColor;
                }

                // Returning the current object for chaining functions
                return this;
            },

            // Building the DOM element
            buildToast: function () {
                // Validating if the options are defined
                if (!this.options) {
                    throw "Toastify is not initialized";
                }

                // Creating the DOM object
                var divElement = document.createElement("div");
                divElement.className = "toastify on " + this.options.className;

                // Positioning toast to left or right or center
                if (!!this.options.position) {
                    divElement.className += " toastify-" + this.options.position;
                } else {
                    // To be depreciated in further versions
                    if (this.options.positionLeft === true) {
                        divElement.className += " toastify-left";
                        console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.')
                    } else {
                        // Default position
                        divElement.className += " toastify-right";
                    }
                }

                // Assigning gravity of element
                divElement.className += " " + this.options.gravity;

                if (this.options.backgroundColor) {
                    // This is being deprecated in favor of using the style HTML DOM property
                    console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
                }

                // Loop through our style object and apply styles to divElement
                for (var property in this.options.style) {
                    divElement.style[property] = this
                        .options
                        .style[property];
                }

                // Announce the toast to screen readers
                if (this.options.ariaLive) {
                    divElement.setAttribute('aria-live', this.options.ariaLive)
                }

                // Adding the toast message/node
                if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
                    // If we have a valid node, we insert it
                    divElement.appendChild(this.options.node)
                } else {
                    if (this.options.escapeMarkup) {
                        divElement.innerText = this.options.text;
                    } else {
                        divElement.innerHTML = this.options.text;
                    }

                    if (this.options.avatar !== "") {
                        var avatarElement = document.createElement("img");
                        avatarElement.src = this.options.avatar;

                        avatarElement.className = "toastify-avatar";

                        if (this.options.position == "left" || this.options.positionLeft === true) {
                            // Adding close icon on the left of content
                            divElement.appendChild(avatarElement);
                        } else {
                            // Adding close icon on the right of content
                            divElement.insertAdjacentElement("afterbegin", avatarElement);
                        }
                    }
                }

                // Adding a close icon to the toast
                if (this.options.close === true) {
                    // Create a span for close element
                    var closeElement = document.createElement("button");
                    closeElement.type = "button";
                    closeElement.setAttribute("aria-label", "Close");
                    closeElement.className = "toast-close";
                    closeElement.innerHTML = "&#10006;";

                    // Triggering the removal of toast from DOM on close click
                    closeElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this.removeElement(this.toastElement);
                        window.clearTimeout(this.toastElement.timeOutValue);
                    }.bind(this));

                    //Calculating screen width
                    var width = window.innerWidth > 0
                        ? window.innerWidth
                        : screen.width;

                    // Adding the close icon to the toast element
                    // Display on the right if screen width is less than or equal to 360px
                    if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
                        // Adding close icon on the left of content
                        divElement.insertAdjacentElement("afterbegin", closeElement);
                    } else {
                        // Adding close icon on the right of content
                        divElement.appendChild(closeElement);
                    }
                }

                // Clear timeout while toast is focused
                if (this.options.stopOnFocus && this.options.duration > 0) {
                    var self = this;
                    // stop countdown
                    divElement.addEventListener("mouseover", function (event) {
                        window.clearTimeout(divElement.timeOutValue);
                    })
                    // add back the timeout
                    divElement.addEventListener("mouseleave", function () {
                        divElement.timeOutValue = window.setTimeout(function () {
                            // Remove the toast from DOM
                            self.removeElement(divElement);
                        }, self.options.duration)
                    })
                }

                // Adding an on-click destination path
                if (typeof this.options.destination !== "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        if (this.options.newWindow === true) {
                            window.open(this.options.destination, "_blank");
                        } else {
                            window.location = this.options.destination;
                        }
                    }.bind(this));
                }

                if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this
                            .options
                            .onClick();
                    }.bind(this));
                }

                // Adding offset
                if (typeof this.options.offset === "object") {

                    var x = getAxisOffsetAValue("x", this.options);
                    var y = getAxisOffsetAValue("y", this.options);

                    var xOffset = this.options.position == "left"
                        ? x
                        : "-" + x;
                    var yOffset = this.options.gravity == "toastify-top"
                        ? y
                        : "-" + y;

                    divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";

                }

                // Returning the generated element
                return divElement;
            },

            // Displaying the toast
            showToast: function () {
                // Creating the DOM object for the toast
                this.toastElement = this.buildToast();

                // Getting the root element to with the toast needs to be added
                var rootElement;
                if (typeof this.options.selector === "string") {
                    rootElement = document.getElementById(this.options.selector);
                } else if (this.options.selector instanceof HTMLElement || (typeof ShadowRoot !== 'undefined' && this.options.selector instanceof ShadowRoot)) {
                    rootElement = this.options.selector;
                } else {
                    rootElement = document.body;
                }

                // Validating if root element is present in DOM
                if (!rootElement) {
                    throw "Root element is not defined";
                }

                // Adding the DOM element
                var elementToInsert = Toastify.defaults.oldestFirst
                    ? rootElement.firstChild
                    : rootElement.lastChild;
                rootElement.insertBefore(this.toastElement, elementToInsert);

                // Repositioning the toasts in case multiple toasts are present
                Toastify.reposition();

                if (this.options.duration > 0) {
                    this.toastElement.timeOutValue = window.setTimeout(function () {
                        // Remove the toast from DOM
                        this.removeElement(this.toastElement);
                    }.bind(this), this.options.duration); // Binding `this` for function invocation
                }

                // Supporting function chaining
                return this;
            },

            hideToast: function () {
                if (this.toastElement.timeOutValue) {
                    clearTimeout(this.toastElement.timeOutValue);
                }
                this.removeElement(this.toastElement);
            },

            // Removing the element from the DOM
            removeElement: function (toastElement) {
                // Hiding the element
                // toastElement.classList.remove("on");
                toastElement.className = toastElement
                    .className
                    .replace(" on", "");

                // Removing the element from DOM after transition end
                window.setTimeout(function () {
                    // remove options node if any
                    if (this.options.node && this.options.node.parentNode) {
                        this
                            .options
                            .node
                            .parentNode
                            .removeChild(this.options.node);
                    }

                    // Remove the element from the DOM, only when the parent node was not removed before.
                    if (toastElement.parentNode) {
                        toastElement
                            .parentNode
                            .removeChild(toastElement);
                    }

                    // Calling the callback function
                    this
                        .options
                        .callback
                        .call(toastElement);

                    // Repositioning the toasts again
                    Toastify.reposition();
                }.bind(this), 400); // Binding `this` for function invocation
            }
        };

        // Positioning the toasts on the DOM
        Toastify.reposition = function () {

            // Top margins with gravity
            var topLeftOffsetSize = {
                top: 15,
                bottom: 15
            };
            var topRightOffsetSize = {
                top: 15,
                bottom: 15
            };
            var offsetSize = {
                top: 15,
                bottom: 15
            };

            // Get all toast messages on the DOM
            var allToasts = document.getElementsByClassName("toastify");

            var classUsed;

            // Modifying the position of each toast element
            for (var i = 0; i < allToasts.length; i++) {
                // Getting the applied gravity
                if (containsClass(allToasts[i], "toastify-top") === true) {
                    classUsed = "toastify-top";
                } else {
                    classUsed = "toastify-bottom";
                }

                var height = allToasts[i].offsetHeight;
                classUsed = classUsed.substr(9, classUsed.length - 1)
                // Spacing between toasts
                var offset = 15;

                var width = window.innerWidth > 0
                    ? window.innerWidth
                    : screen.width;

                // Show toast in center if screen with less than or equal to 360px
                if (width <= 360) {
                    // Setting the position
                    allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";

                    offsetSize[classUsed] += height + offset;
                } else {
                    if (containsClass(allToasts[i], "toastify-left") === true) {
                        // Setting the position
                        allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";

                        topLeftOffsetSize[classUsed] += height + offset;
                    } else {
                        // Setting the position
                        allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";

                        topRightOffsetSize[classUsed] += height + offset;
                    }
                }
            }

            // Supporting function chaining
            return this;
        };

        // Helper function to get offset.
        function getAxisOffsetAValue(axis, options) {

            if (options.offset[axis]) {
                if (isNaN(options.offset[axis])) {
                    return options.offset[axis];
                } else {
                    return options.offset[axis] + 'px';
                }
            }

            return '0px';

        }

        function containsClass(elem, yourClass) {
            if (!elem || typeof yourClass !== "string") {
                return false;
            } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
                return true;
            } else {
                return false;
            }
        }

        // Setting up the prototype for the init object
        Toastify.lib.init.prototype = Toastify.lib;

        // Returning the Toastify function to be assigned to the window object/module
        return Toastify;
    });
</script>
    <style>
  :root {
    --base-font-family: "Calluna", Georgia, serif;
    --base-font-size: 18px;
    --small-font-size: var(--base-font-size) * 0.875;
    --base-line-height: 1.5;
    --spacing-unit: 30px;
    --spacing-unit-line: 7px;
    --text-color: #181818;
    --background-color: #fdfdfd;
    --brand-color: #4d96b9;
    --brand-color-secondary: #109269;
    --brand-color-light: lighten(var(--brand-color-secondary), 1%);
    --brand-color-dark: darken(var(--brand-color-secondary), 1%);
    --grey-color: #141414;
    --grey-color-light: lighten(var(--grey-color), 20%);
    --grey-color-dark: darken(var(--grey-color), 15%);
    --on-palm: 750px;
    --on-laptop: 800px;
    --statblock-main-color: #7a200d;
    --statblock-secondary-color: #922610;
    --statblock-background-color: #fdf1dc;
    --toastContainerTop: auto;
    --toastContainerRight: auto;
    --toastContainerBottom: 8rem;
    --toastContainerLeft: calc(50vw - 8rem);
  }

  a {
    color: blue;
    cursor: pointer;
  }

  .stat-header {
    margin-bottom: 1em;
    margin-top: 1em;
  }
  .stat-value {
    font-size: 20px;
  }

  .stat-block {
    font-size: 13.5px;
    line-height: 1.2em;
    box-sizing: border-box;
    max-width: 100%;
    text-align: left;
    vertical-align: top;
    width: 50%;
    min-width: 280px;
    background: var(--statblock-background-color);
    padding: 5px 10px 20px;
    box-shadow: 0 0 1.5em #867453;
    margin-top: 20px;
    margin-bottom: 10px;
    margin-right: auto;
    margin-left: auto;
  }
  .stat-block p {
    margin-bottom: 10px;
  }
  .stat-block h4 {
    font-weight: bold;
  }
  .orange-border {
    display: block;
    background: #e69a28;
    border: 1px solid #000;
    height: 5px;
    padding: 0 10px 0;
    margin: -10px -10px 0;
    box-sizing: initial;
  }
  .orange-border.bottom {
    margin: 15px -10px -20px;
  }
  .tapered-rule {
    display: block;
    width: 100%;
    height: 5px;
    border: none;
    color: var(--statblock-secondary-color);
    fill: var(--statblock-secondary-color);
    stroke: var(--statblock-secondary-color);
  }
  .top-gap {
    margin: 0 0 8px;
  }
  .bottom-gap {
    margin: 10px 0;
  }
  .creature-heading h1 {
    color: var(--statblock-secondary-color);
    font-size: 23px;
    line-height: 1.2em;
    margin: 10px 0 0;
    letter-spacing: 1px;
    font-variant: small-caps;
    font-weight: bold;
  }
  .creature-heading h2 {
    font-weight: normal;
    font-style: italic;
    font-size: 12px;
    line-height: 1.2em;
    margin: 0 0 10px;
  }
  .property-line h4,
  .property-line p {
    display: inline;
    margin: 0;
    color: var(--statblock-secondary-color);
    font-size: 13.5px;
    line-height: 1.2em;
  }
  .property-line h4 {
    color: var(--statblock-main-color);
  }
  .property-line {
    text-indent: -1em;
    padding-left: 1.1em;
    line-height: 1.4em;
  }
  .property-line.first {
    margin: 8px 0 0;
  }
  .property-line.last {
    margin: 0 0 10px;
  }
  .abilities {
    text-align: center;
    color: var(--statblock-secondary-color);
    margin-bottom: 1em;
  }
  .abilities > div {
    display: inline-block;
    vertical-align: middle;
    width: 12.5%;
    min-width: 40px;
    font-size: 12px;
    line-height: 1em;
  }
  #actions > *,
  #reactions > * {
    border-bottom: 1px solid var(--statblock-main-color);
    color: var(--statblock-main-color);
    font-size: 14px;
    font-weight: normal;
    margin: 10px 0 0;
    padding: 0 0 10px;
    text-indent: 5px;
  }
  #actions,
  #reactions {
    margin: 0 0 10px;
  }
  #actions:last-child,
  #reactions:last-child {
    margin: 0;
  }

  @media print {
    .orange-border {
      display: none;
    }
    .stat-block,
    .property-line,
    .stat-block {
      width: 40%;
      display: inline-block;
      vertical-align: top;
    }
  }
  @media screen and (max-width: 575px) {
    .stat-block {
      /* margin: 5px; */
      width: 100%;
    }
  }

.toastify {
    padding: 12px 20px;
    color: #ffffff;
    display: inline-block;
    box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);
    background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);
    background: linear-gradient(135deg, #73a5ff, #5477f5);
    position: fixed;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
    border-radius: 2px;
    cursor: pointer;
    text-decoration: none;
    max-width: calc(50% - 20px);
    z-index: 2147483647;
}

.toastify.on {
    opacity: 1;
}

.toast-close {
    background: transparent;
    border: 0;
    color: white;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    opacity: 0.4;
    padding: 0 5px;
}

.toastify-right {
    right: 15px;
}

.toastify-left {
    left: 15px;
}

.toastify-top {
    top: -150px;
}

.toastify-bottom {
    bottom: -150px;
}

.toastify-rounded {
    border-radius: 25px;
}

.toastify-avatar {
    width: 1.5em;
    height: 1.5em;
    margin: -7px 5px;
    border-radius: 2px;
}

.toastify-center {
    margin-left: auto;
    margin-right: auto;
    left: 0;
    right: 0;
    max-width: fit-content;
    max-width: -moz-fit-content;
}

@media only screen and (max-width: 360px) {
    .toastify-right, .toastify-left {
        margin-left: auto;
        margin-right: auto;
        left: 0;
        right: 0;
        max-width: fit-content;
    }
}
</style>

</html>