<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elder Brain</title>
</head>
    <body>
        <div class="post">
  <div class="stat-block">
    <hr class="orange-border"/>
    <div class="section-left">
      <div class="creature-heading">
        <div style="display:flex; justify-content:space-between;">
          <h1>Elder Brain</h1>
        </div>
        <h2 style="color:black;">L, Lawful Evil</h2>
      </div>
      <!-- creature heading -->
      <svg height="5" width="100%" class="tapered-rule">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div class="top-stats">
  <!-- property line -->
  <div class="property-line">
    <h4>Hit Points</h4>
    <div >
      <input type="text" style="width:2em;" value=210 (20d10+100)></input>
      <p>210 (20d10+100)</p>
    </div>
  </div>
  <!-- property line -->
  <div class="property-line first">
    <h4>Armor Class:</h4>
    <p>10</p>
  </div>
  <div class="property-line last">
    <h4>Speed:</h4>
    <p>walk 5 ft., swim 10 ft.</p>
  </div>
  <!-- property line -->
  <svg height="5" width="100%" class="tapered-rule">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  <div class="abilities">
    <div>
      <div class="stat-header">
        <b class="stat-value">STR</b>
      </div>
      15 <a class='roll'>+2</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">DEX</b>
      </div>
      10 <a class='roll'>+0</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CON</b>
      </div>
      20 <a class='roll'>+5</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">WIS</b>
      </div>
      19 <a class='roll'>+4</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">INT</b>
      </div>
      21 <a class='roll'>+5</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CHA</b>
      </div>
      24 <a class='roll'>+7</a>
    </div>
  </div>
  <svg height="5" width="100%" class="tapered-rule top-gap">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  

    

      

        

          
            <div class="property-line">
              <h4>Senses:</h4>
              <p>blindsight 120 ft.</p>
            </div>
            

            
              <div class="property-line">
                <h4>Saving Throws:</h4>
                <p>
                  Int <a class='roll'>+10</a>, Wis <a class='roll'>+9</a>, Cha <a class='roll'>+12</a>
                </p>
              </div>
              

              
                <div class="property-line">
                  <h4>Skills:</h4>
                  <p>
                    Arcana <a class='roll'>+10</a>, Deception <a class='roll'>+12</a>, Insight <a class='roll'>+14</a>, Intimidation <a class='roll'>+12</a>, Persuasion <a class='roll'>+12</a>
                  </p>
                </div>
                

                
                  <div class="property-line">
                    <h4>Languages:</h4>
                    <p>understands Common, Deep Speech, and Undercommon but can't speak, telepathy 5 miles</p>
                  </div>
                  

                  
                    <div class="property-line">
                      <h4>Environment:</h4>
                      <p>underdark</p>
                    </div>
                    

                    
                      <div class="property-line">
                        <h4>Challenge:</h4>
                        <p>14</p>
                      </div>
                      

                      

                      </div>
      <svg height="5" width="100%" class="tapered-rule bottom-gap">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div id="actions">
    
        <div class="creature-heading">
            <h1>Traits</h1>
        </div>
        <div>
            
                <div>
                    <b>Creature Sense: </b>
                    <span>The elder brain is aware of the presence of creatures within 5 miles of it that have an Intelligence score of 4 or higher. It knows the distance and direction to each creature, as well as each one's intelligence score, but can't sense anything else about it. A creature protected by a mind blank spell, a nondetection spell, or similar magic can't be perceived in this manner.</span>
                </div>
                <br/>
                
                <div>
                    <b>Legendary Resistance (3/Day): </b>
                    <span>If the elder brain fails a saving throw, it can choose to succeed instead.</span>
                </div>
                <br/>
                
                <div>
                    <b>Magic Resistance: </b>
                    <span>The elder brain has advantage on saving throws against spells and other magical effects.</span>
                </div>
                <br/>
                
                <div>
                    <b>Telepathic Hub: </b>
                    <span>The elder brain can use its telepathy to initiate and maintain telepathic conversations with up to ten creatures at a time. The elder brain can let those creatures telepathically hear each other while connected in this way.</span>
                </div>
                <br/>
                
                <div>
                    <b>Innate Spellcasting (Psionics): </b>
                    <span>The elder brain's innate spellcasting ability is Intelligence (spell save DC 18). It can innately cast the following spells, requiring no components:,At will: detect thoughts, levitate,1/day each: dominate monster, plane shift (self only)</span>
                </div>
                <br/>
                
            </div>
        </div>
        
        
            <div id="actions">
                <div class="creature-heading">
                    <h1>Actions</h1>
                </div>
                <div>
                    
                        <div>
                            <b>Tentacle: </b>
                            <span>Melee Weapon Attack: <a class='roll'>+7</a> to hit, reach 30 ft., one target. 20 <a class='roll'>(4d8 + 2)</a> bludgeoning damage. If the target is a Huge or smaller creature, it is grappled (escape DC 15) and takes 9 <a class='roll'>(1d8 + 5)</a> psychic damage at the start of each of its turns until the grapple ends. The elder brain can have up to four targets grappled at a time.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Mind Blast (Recharge 5-6): </b>
                            <span>The elder brain magically emits psychic energy. Creatures of the elder brain's choice within 60 feet of it must succeed on a DC 18 Intelligence saving throw or take 32 <a class='roll'>(5d10 + 5)</a> psychic damage and be stunned for 1 minute. A target can repeat the saving throw at the end of each of its turns, ending the effect on itself on a success.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Psychic Link: </b>
                            <span>The elder brain targets one incapacitated creature it can perceive with its Creature Sense trait and establishes a psychic link with that creature. Until the psychic link ends, the elder brain can perceive everything the target senses. The target becomes aware that something is linked to its mind once it is no longer incapacitated, and the elder brain can terminate the link at any time (no action required). The target can use an action on its turn to attempt to break the psychic link, doing so with a successful DC 18 Charisma saving throw. On a successful save, the target takes 10 <a class='roll'>(3d6)</a> psychic damage. The psychic link also ends if the target and the elder brain are more than 5 miles apart, with no consequences to the target. The elder brain can form psychic links with up to ten creatures at a time.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Sense Thoughts: </b>
                            <span>The elder brain targets a creature with which it has a psychic link. The elder brain gains insight into the target's reasoning, its emotional state, and thoughts that loom large in its mind (including things the target worries about, loves, or hates). The elder brain can also make a Charisma (Deception) check with advantage to deceive the target's mind into thinking it believes one idea or feels a particular emotion. The target contests this attempt with a Wisdom (Insight) check. If the elder brain succeeds, the mind believes the deception for 1 hour or until evidence of the lie is presented to the target.</span>
                        </div>
                        <br/>
                        
                        <br/>
                    </div>
                </div>
                
                
                        
                            <div id="actions">
                                <div class="creature-heading">
                                    <h1>Legendary Actions</h1>
                                </div>
                                <div>
                                    
                                        <div>
                                            <b>: </b>
                                            <span>The aberration can take 4 legendary actions, choosing from the options below. Only one legendary action can be used at a time and only at the end of another creature's turn. The aberration regains spent legendary actions at the start of its turn.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Tentacle: </b>
                                            <span>The elder brain makes a tentacle attack.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Break Concentration: </b>
                                            <span>The elder brain targets a creature within 120 feet of it with which it has a psychic link. The elder brain breaks the creature's concentration on a spell it has cast. The creature also takes <a class='roll'>1d4 </a>psychic damage per level of the spell.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Psychic Pulse: </b>
                                            <span>The elder brain targets a creature within 120 feet of it with which it has a psychic link. Enemies of the elder brain within 10 feet of that creature take 10 <a class='roll'>(3d6)</a> psychic damage.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Sever Psychic Link: </b>
                                            <span>The elder brain targets a creature within 120 feet of it with which it has a psychic link. The elder brain ends the link, causing the creature to have disadvantage on all ability checks, attack rolls, and saving throws until the end of the creature's next turn.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Lair Actions: </b>
                                            <span>When fighting inside its lair, an elder brain can use lair actions. On initiative count 20 (losing initiative ties), an elder brain can take one lair action to cause one of the following effects; the elder brain can't use the same lair action two rounds in a row:,• The elder brain casts wall of force.,• The elder brain targets one friendly creature it can sense within 120 feet of it. The target has a flash of inspiration and gains advantage on one attack roll, ability check, or saving throw it makes before the end of its next turn. If the target doesn't or can't use this benefit in that time, the inspiration is lost.,• The elder brain targets one creature it can sense within 120 feet of it and anchors it by sheer force of will. The target must succeed on a DC 18 Charisma saving throw or be unable to leave its current space. It can repeat the saving throw at the end of each of its turns, ending the effect on itself on a success.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                        <div>
                                            <b>Regional Effects: </b>
                                            <span>The territory within 5 miles of an elder brain is altered by the creature's psionic presence, which creates one or more of the following effects:,• Creatures within 5 miles of an elder brain feel as if they are being followed, even when they are not.,• The elder brain can overhear any telepathic conversation happening within 5 miles of it. The creature that initiated the telepathic conversation makes a DC 18 Wisdom (Insight) check when telepathic contact is first established. If the check succeeds, the creature is aware that something is eavesdropping on the conversation. The nature of the eavesdropper isn't revealed, and the elder brain can't participate in the telepathic conversation unless it has formed a psychic link with the creature that initiated it.,• Any creature with which the elder brain has formed a psychic link hears faint, incomprehensible whispers in the deepest recesses of its mind. This psychic detritus consists of the elder brain's stray thoughts commingled with those of other creatures to which it is linked.,If the elder brain dies, these effects immediately end.</span>
                                            <br/>
                                        </div>
                                        <br/>
                                        
                                    </div>
                                </div>
                                

      <div id="reactions">
        <div class="creature-heading">
          <h1>
              Description
          </h1>
        </div>
        <p>The ultimate expression of illithid domination, an elder brain sprawls within a vat of viscous brine, touching the thoughts of creatures near and far. It scrawls upon the canvas of their minds, rewriting their thoughts and authoring their dreams.
Psychic Infiltrators.  When an elder brain infiltrates a mind, it alters the creature's perception and deceives its senses, causing it to see, hear, touch, taste, or feel reality according to the elder brain's intent. From across great distances, it implants subconscious suggestions or subtly influences dreams to compel creatures toward a course of action that benefits its grand plan.
When its insidious suggestions fail to take hold, an elder brain asserts its dominance more directly. It seizes control of a resistant mind and controls the creature's body as it would a puppet. Against the rare, strong-willed stalwart that defies it or attacks it, an elder brain sends a blast of overwhelming psychic force to crush the upstart's mind, rendering the creature a thoughtless, drooling shell.
When a mind flayer perishes, the elder brain's servants feed the contents of its skull to their master, which absorbs the illithid's brain and all the knowledge and experience contained therein. In this way the elder brain continually increases its knowledge, uniting the thoughts and experiences of the illithid colony into a unified whole. Mind flayers conceive of this "oneness" as a sacred state in the same way that a worshiper of a human deity might view an eternal afterlife in the heavens-for an elder brain can evoke the persona of any illithid it has ever absorbed.
The ambitions of an elder brain are always tempered by its relative immobility. Although its telepathic senses can reach for miles, moving anywhere is always a dangerous proposition. If forced outside its brine pool, an elder brain will swiftly expire, and transporting an elder brain in its pool through confining and tortuous subterranean tunnels frequently proves difficult or impossible.
Devourer of Thoughts.  An elder brain sustains itself by consuming the brains of other creatures. When the mind flayer servants that guard and tend to an elder brain don't bring its meals directly to it, the elder brain reaches out with tendrils of thought, mentally compelling creatures to come to it so that it may feed upon them.
Hive Mind.  Non-illithids call this creature an elder brain because it acts as the central communication hub for an entire mind flayer colony just as a brain does for a living body. Linked to the elder brain, the colony acts like a single organism, acting in concert as if each illithid were the digit of a hand.
Ego Unhindered.  Each elder brain considers itself and its desires the most important things in the multiverse, the mind flayers in its colony nothing more than extensions of its will. But no two elder brains are alike, and each presides over its colony according to its own unique personality and storehouse of collected knowledge and experience. Some elder brains reign as domineering tyrants, while others serve more benignly as sages, counselors, and repositories of information and lore for the mind flayers that protect and nourish them.
An Elder Brain's Lair. The lair of an elder brain always lies deep in the heart of a mind flayer colony. The creature dwells in a dimly glowing brine pool, filled with foul and brackish water infused with the elder brain's vital fluids and with psionic energy.
Source: Volo's Guide to Monsters p. 173</p>
      </div>
      <hr class="orange-border bottom"/>
    </div>
  </div>
</div>
    </body>
    <script>

    function findToHit(dataString) {
        const pattern = /\+(\d{1,2}) to hit/
        let match = dataString.match(pattern)
        if (match !== null) {
            match = match[1]
        }
        return {
            "exists": match !== null,
            "value": parseInt(match)
        }
    }

    function findDamageStrings(dataString) {
        if (typeof dataString === "string") {
            let damageStrings = []
            // const toHitPattern = /\+(\d{1,2}) to hit/
            const toHitPattern = /\+(\d{1,2})/g
            const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/g
            let damageMatches = dataString.matchAll(damagePattern)
            let toHitMatches = dataString.matchAll(toHitPattern)
            for (let match of toHitMatches) {
                if (toHitMatches !== null) {
                    damageStrings.push(match[0])
                }
            }
            for (let match of damageMatches) {
                if (match !== null) {
                    damageStrings.push(match[0])
                }
            }
            return damageStrings
        }
        return []
    }

    function extractRoll(dataString) {
        const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/
        const toHitPattern = /\+(\d{1,2})/
        let damageMatch = dataString.match(damagePattern)
        let toHitMatch = dataString.match(toHitPattern)
        if (toHitMatch !== null) {
            return {"num": 1, "sides": 20, "mod": toHitMatch[1]}
        }
        if (damageMatch !== null) {
            return {"num": damageMatch[1], "sides": damageMatch[2], "mod": damageMatch[3]}
        }
    }

    function randomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + 1);
    }

    function generateRollText(num, sides, mod) {
        let output = []
        let total = 0
        for (let i = 0; i < num; i++) {
            let roll = randomNumber(1, sides)
            total += roll
            output.push(roll)
            output.push("+")
        }
        output.pop()
        if (mod >= 0 && mod !== "") {
            output.push("+")
            output.push(`(${mod})`)
            total += parseInt(mod) || 0
        } else {
            if (mod !== "") {
                output.push("+")
                output.push(`(${mod})`)
                total += parseInt(mod) || 0
            }
        }
        output.push(` = ${total}`)
        return output.join(" ")
    }

    function splitAroundRoll(dataString, patternMatches) {
        let outPut = []
        let currentPosition = 0
        for (let match of patternMatches) {
            let matchLength = match.length
            let matchStartingPosition = dataString.indexOf(match, currentPosition)
            let matchEndingPosition = matchStartingPosition + matchLength
            outPut.push({
                "value": dataString.slice(currentPosition, matchStartingPosition),
                "replace": false
            })
            currentPosition = matchEndingPosition
            outPut.push({"value": match, "replace": true})
        }
        outPut.push({"value": dataString.slice(currentPosition), "replace": false})
        return outPut;
    }

    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }

    function findSpells(traitText, spell_list) {
        let outPutList = [];
        let wordArray = traitText.split(",")
        for (let word of wordArray) {
            if (word.includes(":")) {
                word = word.slice(word.indexOf(":") + 1)
            }
            if (spell_list.includes(word.trim())) {
                outPutList.push(word)
            }
        }
        return outPutList
    }

    function addSpellIds(chunks, spell_list) {
        for (let chunk of chunks) {
            if (chunk.replace) {
                if (chunk.value.includes(":")) {
                    chunk.value = chunk
                        .value
                        .slice(chunk.value.indexOf(":") + 1)
                }
                chunk["spellId"] = spell_list.indexOf(chunk.value.trim())
            }
        }
        return chunks
    }

    document.addEventListener('DOMContentLoaded', () => {
        document
            .querySelectorAll('.roll')
            .forEach(element => {
                element.addEventListener('click', () => {
                    let roll = extractRoll(element.textContent)
                    let rollText = generateRollText(roll.num, roll.sides, roll.mod);
                    Toastify({
                        text: rollText,
                        duration: 1000,
                        gravity: "bottom", // `top` or `bottom`
                        position: "center", // `left`, `center` or `right`
                        stopOnFocus: true, // Prevents dismissing of toast on hover
                    }).showToast();

                    console.log(rollText)
                });
            });
    });
    (function (root, factory) {
        if (typeof module === "object" && module.exports) {
            module.exports = factory();
        } else {
            root.Toastify = factory();
        }
    })(this, function (global) {
        // Object initialization
        var Toastify = function (options) {
                // Returning a new init object
                return new Toastify
                    .lib
                    .init(options);
            },
            // Library version
            version = "1.12.0";

        // Set the default global options
        Toastify.defaults = {
            oldestFirst: true,
            text: "Toastify is awesome!",
            node: undefined,
            duration: 3000,
            selector: undefined,
            callback: function () {},
            destination: undefined,
            newWindow: false,
            close: false,
            gravity: "toastify-top",
            positionLeft: false,
            position: '',
            backgroundColor: '',
            avatar: "",
            className: "",
            stopOnFocus: true,
            onClick: function () {},
            offset: {
                x: 0,
                y: 0
            },
            escapeMarkup: true,
            ariaLive: 'polite',
            style: {
                background: ''
            }
        };

        // Defining the prototype of the object
        Toastify.lib = Toastify.prototype = {
            toastify: version,

            constructor: Toastify,

            // Initializing the object with required parameters
            init: function (options) {
                // Verifying and validating the input object
                if (!options) {
                    options = {};
                }

                // Creating the options object
                this.options = {};

                this.toastElement = null;

                // Validating the options
                this.options.text = options.text || Toastify.defaults.text; // Display message
                this.options.node = options.node || Toastify.defaults.node; // Display content as node
                this.options.duration = options.duration === 0
                    ? 0
                    : options.duration || Toastify.defaults.duration; // Display duration
                this.options.selector = options.selector || Toastify.defaults.selector; // Parent selector
                this.options.callback = options.callback || Toastify.defaults.callback; // Callback after display
                this.options.destination = options.destination || Toastify.defaults.destination; // On-click destination
                this.options.newWindow = options.newWindow || Toastify.defaults.newWindow; // Open destination in new window
                this.options.close = options.close || Toastify.defaults.close; // Show toast close icon
                this.options.gravity = options.gravity === "bottom"
                    ? "toastify-bottom"
                    : Toastify.defaults.gravity; // toast position - top or bottom
                this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft; // toast position - left or right
                this.options.position = options.position || Toastify.defaults.position; // toast position - left or right
                this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor; // toast background color
                this.options.avatar = options.avatar || Toastify.defaults.avatar; // img element src - url or a path
                this.options.className = options.className || Toastify.defaults.className; // additional class names for the toast
                this.options.stopOnFocus = options.stopOnFocus === undefined
                    ? Toastify.defaults.stopOnFocus
                    : options.stopOnFocus; // stop timeout on focus
                this.options.onClick = options.onClick || Toastify.defaults.onClick; // Callback after click
                this.options.offset = options.offset || Toastify.defaults.offset; // toast offset
                this.options.escapeMarkup = options.escapeMarkup !== undefined
                    ? options.escapeMarkup
                    : Toastify.defaults.escapeMarkup;
                this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
                this.options.style = options.style || Toastify.defaults.style;
                if (options.backgroundColor) {
                    this.options.style.background = options.backgroundColor;
                }

                // Returning the current object for chaining functions
                return this;
            },

            // Building the DOM element
            buildToast: function () {
                // Validating if the options are defined
                if (!this.options) {
                    throw "Toastify is not initialized";
                }

                // Creating the DOM object
                var divElement = document.createElement("div");
                divElement.className = "toastify on " + this.options.className;

                // Positioning toast to left or right or center
                if (!!this.options.position) {
                    divElement.className += " toastify-" + this.options.position;
                } else {
                    // To be depreciated in further versions
                    if (this.options.positionLeft === true) {
                        divElement.className += " toastify-left";
                        console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.')
                    } else {
                        // Default position
                        divElement.className += " toastify-right";
                    }
                }

                // Assigning gravity of element
                divElement.className += " " + this.options.gravity;

                if (this.options.backgroundColor) {
                    // This is being deprecated in favor of using the style HTML DOM property
                    console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
                }

                // Loop through our style object and apply styles to divElement
                for (var property in this.options.style) {
                    divElement.style[property] = this
                        .options
                        .style[property];
                }

                // Announce the toast to screen readers
                if (this.options.ariaLive) {
                    divElement.setAttribute('aria-live', this.options.ariaLive)
                }

                // Adding the toast message/node
                if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
                    // If we have a valid node, we insert it
                    divElement.appendChild(this.options.node)
                } else {
                    if (this.options.escapeMarkup) {
                        divElement.innerText = this.options.text;
                    } else {
                        divElement.innerHTML = this.options.text;
                    }

                    if (this.options.avatar !== "") {
                        var avatarElement = document.createElement("img");
                        avatarElement.src = this.options.avatar;

                        avatarElement.className = "toastify-avatar";

                        if (this.options.position == "left" || this.options.positionLeft === true) {
                            // Adding close icon on the left of content
                            divElement.appendChild(avatarElement);
                        } else {
                            // Adding close icon on the right of content
                            divElement.insertAdjacentElement("afterbegin", avatarElement);
                        }
                    }
                }

                // Adding a close icon to the toast
                if (this.options.close === true) {
                    // Create a span for close element
                    var closeElement = document.createElement("button");
                    closeElement.type = "button";
                    closeElement.setAttribute("aria-label", "Close");
                    closeElement.className = "toast-close";
                    closeElement.innerHTML = "&#10006;";

                    // Triggering the removal of toast from DOM on close click
                    closeElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this.removeElement(this.toastElement);
                        window.clearTimeout(this.toastElement.timeOutValue);
                    }.bind(this));

                    //Calculating screen width
                    var width = window.innerWidth > 0
                        ? window.innerWidth
                        : screen.width;

                    // Adding the close icon to the toast element
                    // Display on the right if screen width is less than or equal to 360px
                    if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
                        // Adding close icon on the left of content
                        divElement.insertAdjacentElement("afterbegin", closeElement);
                    } else {
                        // Adding close icon on the right of content
                        divElement.appendChild(closeElement);
                    }
                }

                // Clear timeout while toast is focused
                if (this.options.stopOnFocus && this.options.duration > 0) {
                    var self = this;
                    // stop countdown
                    divElement.addEventListener("mouseover", function (event) {
                        window.clearTimeout(divElement.timeOutValue);
                    })
                    // add back the timeout
                    divElement.addEventListener("mouseleave", function () {
                        divElement.timeOutValue = window.setTimeout(function () {
                            // Remove the toast from DOM
                            self.removeElement(divElement);
                        }, self.options.duration)
                    })
                }

                // Adding an on-click destination path
                if (typeof this.options.destination !== "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        if (this.options.newWindow === true) {
                            window.open(this.options.destination, "_blank");
                        } else {
                            window.location = this.options.destination;
                        }
                    }.bind(this));
                }

                if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this
                            .options
                            .onClick();
                    }.bind(this));
                }

                // Adding offset
                if (typeof this.options.offset === "object") {

                    var x = getAxisOffsetAValue("x", this.options);
                    var y = getAxisOffsetAValue("y", this.options);

                    var xOffset = this.options.position == "left"
                        ? x
                        : "-" + x;
                    var yOffset = this.options.gravity == "toastify-top"
                        ? y
                        : "-" + y;

                    divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";

                }

                // Returning the generated element
                return divElement;
            },

            // Displaying the toast
            showToast: function () {
                // Creating the DOM object for the toast
                this.toastElement = this.buildToast();

                // Getting the root element to with the toast needs to be added
                var rootElement;
                if (typeof this.options.selector === "string") {
                    rootElement = document.getElementById(this.options.selector);
                } else if (this.options.selector instanceof HTMLElement || (typeof ShadowRoot !== 'undefined' && this.options.selector instanceof ShadowRoot)) {
                    rootElement = this.options.selector;
                } else {
                    rootElement = document.body;
                }

                // Validating if root element is present in DOM
                if (!rootElement) {
                    throw "Root element is not defined";
                }

                // Adding the DOM element
                var elementToInsert = Toastify.defaults.oldestFirst
                    ? rootElement.firstChild
                    : rootElement.lastChild;
                rootElement.insertBefore(this.toastElement, elementToInsert);

                // Repositioning the toasts in case multiple toasts are present
                Toastify.reposition();

                if (this.options.duration > 0) {
                    this.toastElement.timeOutValue = window.setTimeout(function () {
                        // Remove the toast from DOM
                        this.removeElement(this.toastElement);
                    }.bind(this), this.options.duration); // Binding `this` for function invocation
                }

                // Supporting function chaining
                return this;
            },

            hideToast: function () {
                if (this.toastElement.timeOutValue) {
                    clearTimeout(this.toastElement.timeOutValue);
                }
                this.removeElement(this.toastElement);
            },

            // Removing the element from the DOM
            removeElement: function (toastElement) {
                // Hiding the element
                // toastElement.classList.remove("on");
                toastElement.className = toastElement
                    .className
                    .replace(" on", "");

                // Removing the element from DOM after transition end
                window.setTimeout(function () {
                    // remove options node if any
                    if (this.options.node && this.options.node.parentNode) {
                        this
                            .options
                            .node
                            .parentNode
                            .removeChild(this.options.node);
                    }

                    // Remove the element from the DOM, only when the parent node was not removed before.
                    if (toastElement.parentNode) {
                        toastElement
                            .parentNode
                            .removeChild(toastElement);
                    }

                    // Calling the callback function
                    this
                        .options
                        .callback
                        .call(toastElement);

                    // Repositioning the toasts again
                    Toastify.reposition();
                }.bind(this), 400); // Binding `this` for function invocation
            }
        };

        // Positioning the toasts on the DOM
        Toastify.reposition = function () {

            // Top margins with gravity
            var topLeftOffsetSize = {
                top: 15,
                bottom: 15
            };
            var topRightOffsetSize = {
                top: 15,
                bottom: 15
            };
            var offsetSize = {
                top: 15,
                bottom: 15
            };

            // Get all toast messages on the DOM
            var allToasts = document.getElementsByClassName("toastify");

            var classUsed;

            // Modifying the position of each toast element
            for (var i = 0; i < allToasts.length; i++) {
                // Getting the applied gravity
                if (containsClass(allToasts[i], "toastify-top") === true) {
                    classUsed = "toastify-top";
                } else {
                    classUsed = "toastify-bottom";
                }

                var height = allToasts[i].offsetHeight;
                classUsed = classUsed.substr(9, classUsed.length - 1)
                // Spacing between toasts
                var offset = 15;

                var width = window.innerWidth > 0
                    ? window.innerWidth
                    : screen.width;

                // Show toast in center if screen with less than or equal to 360px
                if (width <= 360) {
                    // Setting the position
                    allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";

                    offsetSize[classUsed] += height + offset;
                } else {
                    if (containsClass(allToasts[i], "toastify-left") === true) {
                        // Setting the position
                        allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";

                        topLeftOffsetSize[classUsed] += height + offset;
                    } else {
                        // Setting the position
                        allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";

                        topRightOffsetSize[classUsed] += height + offset;
                    }
                }
            }

            // Supporting function chaining
            return this;
        };

        // Helper function to get offset.
        function getAxisOffsetAValue(axis, options) {

            if (options.offset[axis]) {
                if (isNaN(options.offset[axis])) {
                    return options.offset[axis];
                } else {
                    return options.offset[axis] + 'px';
                }
            }

            return '0px';

        }

        function containsClass(elem, yourClass) {
            if (!elem || typeof yourClass !== "string") {
                return false;
            } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
                return true;
            } else {
                return false;
            }
        }

        // Setting up the prototype for the init object
        Toastify.lib.init.prototype = Toastify.lib;

        // Returning the Toastify function to be assigned to the window object/module
        return Toastify;
    });
</script>
    <style>
  :root {
    --base-font-family: "Calluna", Georgia, serif;
    --base-font-size: 18px;
    --small-font-size: var(--base-font-size) * 0.875;
    --base-line-height: 1.5;
    --spacing-unit: 30px;
    --spacing-unit-line: 7px;
    --text-color: #181818;
    --background-color: #fdfdfd;
    --brand-color: #4d96b9;
    --brand-color-secondary: #109269;
    --brand-color-light: lighten(var(--brand-color-secondary), 1%);
    --brand-color-dark: darken(var(--brand-color-secondary), 1%);
    --grey-color: #141414;
    --grey-color-light: lighten(var(--grey-color), 20%);
    --grey-color-dark: darken(var(--grey-color), 15%);
    --on-palm: 750px;
    --on-laptop: 800px;
    --statblock-main-color: #7a200d;
    --statblock-secondary-color: #922610;
    --statblock-background-color: #fdf1dc;
    --toastContainerTop: auto;
    --toastContainerRight: auto;
    --toastContainerBottom: 8rem;
    --toastContainerLeft: calc(50vw - 8rem);
  }

  a {
    color: blue;
    cursor: pointer;
  }

  .stat-header {
    margin-bottom: 1em;
    margin-top: 1em;
  }
  .stat-value {
    font-size: 20px;
  }

  .stat-block {
    font-size: 13.5px;
    line-height: 1.2em;
    box-sizing: border-box;
    max-width: 100%;
    text-align: left;
    vertical-align: top;
    width: 50%;
    min-width: 280px;
    background: var(--statblock-background-color);
    padding: 5px 10px 20px;
    box-shadow: 0 0 1.5em #867453;
    margin-top: 20px;
    margin-bottom: 10px;
    margin-right: auto;
    margin-left: auto;
  }
  .stat-block p {
    margin-bottom: 10px;
  }
  .stat-block h4 {
    font-weight: bold;
  }
  .orange-border {
    display: block;
    background: #e69a28;
    border: 1px solid #000;
    height: 5px;
    padding: 0 10px 0;
    margin: -10px -10px 0;
    box-sizing: initial;
  }
  .orange-border.bottom {
    margin: 15px -10px -20px;
  }
  .tapered-rule {
    display: block;
    width: 100%;
    height: 5px;
    border: none;
    color: var(--statblock-secondary-color);
    fill: var(--statblock-secondary-color);
    stroke: var(--statblock-secondary-color);
  }
  .top-gap {
    margin: 0 0 8px;
  }
  .bottom-gap {
    margin: 10px 0;
  }
  .creature-heading h1 {
    color: var(--statblock-secondary-color);
    font-size: 23px;
    line-height: 1.2em;
    margin: 10px 0 0;
    letter-spacing: 1px;
    font-variant: small-caps;
    font-weight: bold;
  }
  .creature-heading h2 {
    font-weight: normal;
    font-style: italic;
    font-size: 12px;
    line-height: 1.2em;
    margin: 0 0 10px;
  }
  .property-line h4,
  .property-line p {
    display: inline;
    margin: 0;
    color: var(--statblock-secondary-color);
    font-size: 13.5px;
    line-height: 1.2em;
  }
  .property-line h4 {
    color: var(--statblock-main-color);
  }
  .property-line {
    text-indent: -1em;
    padding-left: 1.1em;
    line-height: 1.4em;
  }
  .property-line.first {
    margin: 8px 0 0;
  }
  .property-line.last {
    margin: 0 0 10px;
  }
  .abilities {
    text-align: center;
    color: var(--statblock-secondary-color);
    margin-bottom: 1em;
  }
  .abilities > div {
    display: inline-block;
    vertical-align: middle;
    width: 12.5%;
    min-width: 40px;
    font-size: 12px;
    line-height: 1em;
  }
  #actions > *,
  #reactions > * {
    border-bottom: 1px solid var(--statblock-main-color);
    color: var(--statblock-main-color);
    font-size: 14px;
    font-weight: normal;
    margin: 10px 0 0;
    padding: 0 0 10px;
    text-indent: 5px;
  }
  #actions,
  #reactions {
    margin: 0 0 10px;
  }
  #actions:last-child,
  #reactions:last-child {
    margin: 0;
  }

  @media print {
    .orange-border {
      display: none;
    }
    .stat-block,
    .property-line,
    .stat-block {
      width: 40%;
      display: inline-block;
      vertical-align: top;
    }
  }
  @media screen and (max-width: 575px) {
    .stat-block {
      /* margin: 5px; */
      width: 100%;
    }
  }

.toastify {
    padding: 12px 20px;
    color: #ffffff;
    display: inline-block;
    box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);
    background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);
    background: linear-gradient(135deg, #73a5ff, #5477f5);
    position: fixed;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
    border-radius: 2px;
    cursor: pointer;
    text-decoration: none;
    max-width: calc(50% - 20px);
    z-index: 2147483647;
}

.toastify.on {
    opacity: 1;
}

.toast-close {
    background: transparent;
    border: 0;
    color: white;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    opacity: 0.4;
    padding: 0 5px;
}

.toastify-right {
    right: 15px;
}

.toastify-left {
    left: 15px;
}

.toastify-top {
    top: -150px;
}

.toastify-bottom {
    bottom: -150px;
}

.toastify-rounded {
    border-radius: 25px;
}

.toastify-avatar {
    width: 1.5em;
    height: 1.5em;
    margin: -7px 5px;
    border-radius: 2px;
}

.toastify-center {
    margin-left: auto;
    margin-right: auto;
    left: 0;
    right: 0;
    max-width: fit-content;
    max-width: -moz-fit-content;
}

@media only screen and (max-width: 360px) {
    .toastify-right, .toastify-left {
        margin-left: auto;
        margin-right: auto;
        left: 0;
        right: 0;
        max-width: fit-content;
    }
}
</style>

</html>