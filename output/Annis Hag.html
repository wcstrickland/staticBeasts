<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annis Hag</title>
</head>
    <body>
        <div class="post">
  <div class="stat-block">
    <hr class="orange-border"/>
    <div class="section-left">
      <div class="creature-heading">
        <div style="display:flex; justify-content:space-between;">
          <h1>Annis Hag</h1>
        </div>
        <h2 style="color:black;">L, Chaotic Evil</h2>
      </div>
      <!-- creature heading -->
      <svg height="5" width="100%" class="tapered-rule">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div class="top-stats">
  <!-- property line -->
  <div class="property-line">
    <h4>Hit Points</h4>
    <div >
      <input type="text" style="width:2em;" value=75 (10d10+20)></input>
      <p>75 (10d10+20)</p>
    </div>
  </div>
  <!-- property line -->
  <div class="property-line first">
    <h4>Armor Class:</h4>
    <p>17 (natural armor)</p>
  </div>
  <div class="property-line last">
    <h4>Speed:</h4>
    <p>walk 40 ft.</p>
  </div>
  <!-- property line -->
  <svg height="5" width="100%" class="tapered-rule">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  <div class="abilities">
    <div>
      <div class="stat-header">
        <b class="stat-value">STR</b>
      </div>
      21 <a class='roll'>+5</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">DEX</b>
      </div>
      12 <a class='roll'>+1</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CON</b>
      </div>
      14 <a class='roll'>+2</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">WIS</b>
      </div>
      14 <a class='roll'>+2</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">INT</b>
      </div>
      13 <a class='roll'>+1</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CHA</b>
      </div>
      15 <a class='roll'>+2</a>
    </div>
  </div>
  <svg height="5" width="100%" class="tapered-rule top-gap">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  

    
      <div class="property-line">
        <h4>Damage Resistances:</h4>
        <p>cold; bludgeoning, piercing, slashing from nonmagical attacks</p>
      </div>
      

      

        

          
            <div class="property-line">
              <h4>Senses:</h4>
              <p>darkvision 60 ft.</p>
            </div>
            

            
              <div class="property-line">
                <h4>Saving Throws:</h4>
                <p>
                  Con <a class='roll'>+5</a>
                </p>
              </div>
              

              
                <div class="property-line">
                  <h4>Skills:</h4>
                  <p>
                    Deception <a class='roll'>+5</a>, Perception <a class='roll'>+5</a>
                  </p>
                </div>
                

                
                  <div class="property-line">
                    <h4>Languages:</h4>
                    <p>Common, Giant, Sylvan</p>
                  </div>
                  

                  
                    <div class="property-line">
                      <h4>Environment:</h4>
                      <p>mountain, hill</p>
                    </div>
                    

                    
                      <div class="property-line">
                        <h4>Challenge:</h4>
                        <p>6</p>
                      </div>
                      

                      
                        <div class="property-line">
                          <h4>Spell Slots:</h4>
                          <p>4, 3, 3, 3, 2, 1,4, 3, 3, 3, 2, 1,4, 3, 3, 3, 2, 1,4, 3, 3, 3, 2, 1</p>
                        </div>
                        

                      </div>
      <svg height="5" width="100%" class="tapered-rule bottom-gap">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div id="actions">
    
        <div class="creature-heading">
            <h1>Traits</h1>
        </div>
        <div>
            
                <div>
                    <b>Hag Coven: </b>
                    <span>When hags must work together, they form covens, in spite of their selfish natures. A coven is made up of hags of any type, all of whom are equals within the group. However, each of the hags continues to desire more personal power.,A coven consists of three hags so that any arguments between two hags can be settled by the third. If more than three hags ever come together, as might happen if two covens come into conflict, the result is usually chaos.</span>
                </div>
                <br/>
                
                <div>
                    <b>Hag Eye (Coven Only): </b>
                    <span>A hag coven can craft a magic item called a hag eye, which is made from a real eye coated in varnish and often fitted to a pendant or other wearable item. The hag eye is usually entrusted to a minion for safekeeping and transport. A hag in the coven can take an action to see what the hag eye sees if the hag eye is on the same plane of existence. A hag eye has AC 10, 1 hit point, and darkvision with a radius of 60 feet. If it is destroyed, each coven member takes 3d10 psychic damage and is blinded for 24 hours.,A hag coven can have only one hag eye at a time, and creating a new one requires all three members of the coven to perform a ritual. The ritual takes 1 hour, and the hags can't perform it while blinded. During the ritual, if the hags take any action other than performing the ritual, they must start over.</span>
                </div>
                <br/>
                
                <div>
                    <b>Innate Spellcasting: </b>
                    <span>The hag's innate spellcasting ability is Charisma (spell save DC 13). She can innately cast the following spells:,3/day each: disguise self (including the form of a Medium humanoid), fog cloud</span>
                </div>
                <br/>
                
                <div>
                    <b>Shared Spellcasting (Coven Only): </b>
                    <span>While all three members of a hag coven are within 30 feet of one another, they can each cast the following spells from the wizard's spell list but must share the spell slots among themselves:,• 1st level (4 slots): identify, ray of sickness,• 2nd level (3 slots): hold person, locate object,• 3rd level (3 slots): bestow curse, counterspell, lightning bolt,• 4th level (3 slots): phantasmal killer, polymorph,• 5th level (2 slots): contact other plane, scrying,• 6th level (1 slots): eyebite,For casting these spells, each hag is a 12th-level spellcaster that uses Intelligence as her spellcasting ability. The spell save DC is 12 + the hag's Intelligence modifier, and the spell attack bonus is 4 + the hag's Intelligence modifier.</span>
                </div>
                <br/>
                
                <div>
                    <b>Variant: Death Coven: </b>
                    <span>For a death coven, replace the spell list of the hags' Shared Spellcasting trait with the following spells:,• 1st level (4 slots): false life, inflict wounds,• 2nd level (3 slots): gentle repose, ray of enfeeblement,• 3rd level (3 slots): animate dead, revivify, speak with dead,• 4th level (3 slots): blight, death ward,• 5th level (2 slots): contagion, raise dead,• 6th level (1 slots): circle of death</span>
                </div>
                <br/>
                
                <div>
                    <b>Variant: Nature Coven: </b>
                    <span>For a nature coven, replace the spell list of the hags' Shared Spellcasting trait with the following spells:,• 1st level (4 slots): entangle, speak with animals,• 2nd level (3 slots): flaming sphere, moonbeam, spike growth,• 3rd level (3 slots): call lightning, plant growth,• 4th level (3 slots): dominate beast, grasping vine,• 5th level (2 slots): insect plague, tree stride,• 6th level (1 slots): wall of thorns</span>
                </div>
                <br/>
                
                <div>
                    <b>Variant: Prophecy Coven: </b>
                    <span>For a prophecy coven, replace the spell list of the hags' Shared Spellcasting trait with the following spells:,• 1st level (4 slots): bane, bless,• 2nd level (3 slots): augury, detect thoughts,• 3rd level (3 slots): clairvoyance, dispel magic, nondetection,• 4th level (3 slots): arcane eye, locate creature,• 5th level (2 slots): geas, legend lore,• 6th level (1 slots): true seeing</span>
                </div>
                <br/>
                
            </div>
        </div>
        
        
            <div id="actions">
                <div class="creature-heading">
                    <h1>Actions</h1>
                </div>
                <div>
                    
                        <div>
                            <b>Multiattack: </b>
                            <span>The annis makes three attacks: one with her bite and two with her claws.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Bite: </b>
                            <span>Melee Weapon Attack: <a class='roll'>+8</a> to hit, reach 5 ft., one target. 15 <a class='roll'>(3d6 + 5)</a> piercing damage.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Claw: </b>
                            <span>Melee Weapon Attack: <a class='roll'>+8</a> to hit, reach 5 ft., one target. 15 <a class='roll'>(3d6 + 5)</a> slashing damage.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Crushing Hug: </b>
                            <span>Melee Weapon Attack: <a class='roll'>+8</a> to hit, reach 5 ft., one target. 36 <a class='roll'>(9d6 + 5)</a> bludgeoning damage, and the target is grappled (escape DC 15) if it is a Large or smaller creature. Until the grapple ends, the target takes 36 <a class='roll'>(9d6 + 5)</a> bludgeoning damage at the start of each of the hag's turns. The hag can't make attacks while grappling a creature in this way.</span>
                        </div>
                        <br/>
                        
                        <br/>
                    </div>
                </div>
                
                
                        

      <div id="reactions">
        <div class="creature-heading">
          <h1>
              Description
          </h1>
        </div>
        <p>Annis hags lair in mountains or hills. Despite being hunchbacked and hump-shouldered, they are the largest and most physically imposing of their kind, standing eight feet tall.
Tormenting the Weak.  Although annis hags can easily tear a grown man apart, they love hunting children, preferring their flesh above all others. They use the flayed skin of such victims to make supple leather, and a hag's lair often shows the signs of this industry.
Annis hags leave tokens of their cruelty at the edges of forests and other areas they claim. In this way, they provoke fear and paranoia in nearby villages and settlements. To an annis hag, nothing is sweeter than turning a vibrant community into a place paralyzed with terror, where folk never venture out at night, strangers are met with suspicion and anger, and parents warn their children to "be good, or the annis will get you."
Child Corrupter.  When an annis feels especially cruel, she disguises herself as a kindly-looking elderly woman, approaches a child in a remote place, and gives it an iron token that it can use to confide in her. Over time, "Granny" convinces the child that it's okay to have bad thoughts and do bad deeds-starting with breaking things or wandering outside without permission, then graduating to pushing someone down the stairs or setting a house on fire. Sooner or later, the child's family and community become terrified of the "bad seed" and must face the awful decision of whether the child should be punished or exiled.
Tribe Mother.  Much in the way that they befriend children in order to corrupt them, annis hags have a tendency for adopting a group of ogres, trolls, or other loutish creatures, ruling them through brute strength, verbal abuse, and superstition.
Covens.  An annis hag that is part of a coven (see the "Hag Covens" sidebar in the Monster Manual) has a challenge rating of 8 (3,900 XP).
Iron Token. An annis hag can pull out one of her iron teeth or nails and spend 1 minute shaping and polishing it into the form of a coin, a ring, or a tiny mirror. Thereafter, any creature that holds this iron token can have a whispered conversation with the hag, provided the creature and the hag are on the same plane of existence and within 10 miles of each other. The holder of the token can hear only the hag's voice, not those of any other creatures or any ambient noise around the hag. Similarly, the hag can hear the holder of the token and not the noise around it.
A hag can have up to three iron tokens active at one time. As an action, she can discern the direction and approximate distance to all of her active tokens. She can instantaneously deactivate any of her tokens at any distance (no action required), whereupon the token retains its current form but loses its magical properties.
Source: Volo's Guide to Monsters p. 159, Mythic Odysseys of Theros</p>
      </div>
      <hr class="orange-border bottom"/>
    </div>
  </div>
</div>
    </body>
    <script>

    function findToHit(dataString) {
        const pattern = /\+(\d{1,2}) to hit/
        let match = dataString.match(pattern)
        if (match !== null) {
            match = match[1]
        }
        return {
            "exists": match !== null,
            "value": parseInt(match)
        }
    }

    function findDamageStrings(dataString) {
        if (typeof dataString === "string") {
            let damageStrings = []
            // const toHitPattern = /\+(\d{1,2}) to hit/
            const toHitPattern = /\+(\d{1,2})/g
            const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/g
            let damageMatches = dataString.matchAll(damagePattern)
            let toHitMatches = dataString.matchAll(toHitPattern)
            for (let match of toHitMatches) {
                if (toHitMatches !== null) {
                    damageStrings.push(match[0])
                }
            }
            for (let match of damageMatches) {
                if (match !== null) {
                    damageStrings.push(match[0])
                }
            }
            return damageStrings
        }
        return []
    }

    function extractRoll(dataString) {
        const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/
        const toHitPattern = /\+(\d{1,2})/
        let damageMatch = dataString.match(damagePattern)
        let toHitMatch = dataString.match(toHitPattern)
        if (toHitMatch !== null) {
            return {"num": 1, "sides": 20, "mod": toHitMatch[1]}
        }
        if (damageMatch !== null) {
            return {"num": damageMatch[1], "sides": damageMatch[2], "mod": damageMatch[3]}
        }
    }

    function randomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + 1);
    }

    function generateRollText(num, sides, mod) {
        let output = []
        let total = 0
        for (let i = 0; i < num; i++) {
            let roll = randomNumber(1, sides)
            total += roll
            output.push(roll)
            output.push("+")
        }
        output.pop()
        if (mod >= 0 && mod !== "") {
            output.push("+")
            output.push(`(${mod})`)
            total += parseInt(mod) || 0
        } else {
            if (mod !== "") {
                output.push("+")
                output.push(`(${mod})`)
                total += parseInt(mod) || 0
            }
        }
        output.push(` = ${total}`)
        return output.join(" ")
    }

    function splitAroundRoll(dataString, patternMatches) {
        let outPut = []
        let currentPosition = 0
        for (let match of patternMatches) {
            let matchLength = match.length
            let matchStartingPosition = dataString.indexOf(match, currentPosition)
            let matchEndingPosition = matchStartingPosition + matchLength
            outPut.push({
                "value": dataString.slice(currentPosition, matchStartingPosition),
                "replace": false
            })
            currentPosition = matchEndingPosition
            outPut.push({"value": match, "replace": true})
        }
        outPut.push({"value": dataString.slice(currentPosition), "replace": false})
        return outPut;
    }

    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }

    function findSpells(traitText, spell_list) {
        let outPutList = [];
        let wordArray = traitText.split(",")
        for (let word of wordArray) {
            if (word.includes(":")) {
                word = word.slice(word.indexOf(":") + 1)
            }
            if (spell_list.includes(word.trim())) {
                outPutList.push(word)
            }
        }
        return outPutList
    }

    function addSpellIds(chunks, spell_list) {
        for (let chunk of chunks) {
            if (chunk.replace) {
                if (chunk.value.includes(":")) {
                    chunk.value = chunk
                        .value
                        .slice(chunk.value.indexOf(":") + 1)
                }
                chunk["spellId"] = spell_list.indexOf(chunk.value.trim())
            }
        }
        return chunks
    }

    document.addEventListener('DOMContentLoaded', () => {
        document
            .querySelectorAll('.roll')
            .forEach(element => {
                element.addEventListener('click', () => {
                    let roll = extractRoll(element.textContent)
                    let rollText = generateRollText(roll.num, roll.sides, roll.mod);
                    Toastify({
                        text: rollText,
                        duration: 1000,
                        gravity: "bottom", // `top` or `bottom`
                        position: "center", // `left`, `center` or `right`
                        stopOnFocus: true, // Prevents dismissing of toast on hover
                    }).showToast();

                    console.log(rollText)
                });
            });
    });
    (function (root, factory) {
        if (typeof module === "object" && module.exports) {
            module.exports = factory();
        } else {
            root.Toastify = factory();
        }
    })(this, function (global) {
        // Object initialization
        var Toastify = function (options) {
                // Returning a new init object
                return new Toastify
                    .lib
                    .init(options);
            },
            // Library version
            version = "1.12.0";

        // Set the default global options
        Toastify.defaults = {
            oldestFirst: true,
            text: "Toastify is awesome!",
            node: undefined,
            duration: 3000,
            selector: undefined,
            callback: function () {},
            destination: undefined,
            newWindow: false,
            close: false,
            gravity: "toastify-top",
            positionLeft: false,
            position: '',
            backgroundColor: '',
            avatar: "",
            className: "",
            stopOnFocus: true,
            onClick: function () {},
            offset: {
                x: 0,
                y: 0
            },
            escapeMarkup: true,
            ariaLive: 'polite',
            style: {
                background: ''
            }
        };

        // Defining the prototype of the object
        Toastify.lib = Toastify.prototype = {
            toastify: version,

            constructor: Toastify,

            // Initializing the object with required parameters
            init: function (options) {
                // Verifying and validating the input object
                if (!options) {
                    options = {};
                }

                // Creating the options object
                this.options = {};

                this.toastElement = null;

                // Validating the options
                this.options.text = options.text || Toastify.defaults.text; // Display message
                this.options.node = options.node || Toastify.defaults.node; // Display content as node
                this.options.duration = options.duration === 0
                    ? 0
                    : options.duration || Toastify.defaults.duration; // Display duration
                this.options.selector = options.selector || Toastify.defaults.selector; // Parent selector
                this.options.callback = options.callback || Toastify.defaults.callback; // Callback after display
                this.options.destination = options.destination || Toastify.defaults.destination; // On-click destination
                this.options.newWindow = options.newWindow || Toastify.defaults.newWindow; // Open destination in new window
                this.options.close = options.close || Toastify.defaults.close; // Show toast close icon
                this.options.gravity = options.gravity === "bottom"
                    ? "toastify-bottom"
                    : Toastify.defaults.gravity; // toast position - top or bottom
                this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft; // toast position - left or right
                this.options.position = options.position || Toastify.defaults.position; // toast position - left or right
                this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor; // toast background color
                this.options.avatar = options.avatar || Toastify.defaults.avatar; // img element src - url or a path
                this.options.className = options.className || Toastify.defaults.className; // additional class names for the toast
                this.options.stopOnFocus = options.stopOnFocus === undefined
                    ? Toastify.defaults.stopOnFocus
                    : options.stopOnFocus; // stop timeout on focus
                this.options.onClick = options.onClick || Toastify.defaults.onClick; // Callback after click
                this.options.offset = options.offset || Toastify.defaults.offset; // toast offset
                this.options.escapeMarkup = options.escapeMarkup !== undefined
                    ? options.escapeMarkup
                    : Toastify.defaults.escapeMarkup;
                this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
                this.options.style = options.style || Toastify.defaults.style;
                if (options.backgroundColor) {
                    this.options.style.background = options.backgroundColor;
                }

                // Returning the current object for chaining functions
                return this;
            },

            // Building the DOM element
            buildToast: function () {
                // Validating if the options are defined
                if (!this.options) {
                    throw "Toastify is not initialized";
                }

                // Creating the DOM object
                var divElement = document.createElement("div");
                divElement.className = "toastify on " + this.options.className;

                // Positioning toast to left or right or center
                if (!!this.options.position) {
                    divElement.className += " toastify-" + this.options.position;
                } else {
                    // To be depreciated in further versions
                    if (this.options.positionLeft === true) {
                        divElement.className += " toastify-left";
                        console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.')
                    } else {
                        // Default position
                        divElement.className += " toastify-right";
                    }
                }

                // Assigning gravity of element
                divElement.className += " " + this.options.gravity;

                if (this.options.backgroundColor) {
                    // This is being deprecated in favor of using the style HTML DOM property
                    console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
                }

                // Loop through our style object and apply styles to divElement
                for (var property in this.options.style) {
                    divElement.style[property] = this
                        .options
                        .style[property];
                }

                // Announce the toast to screen readers
                if (this.options.ariaLive) {
                    divElement.setAttribute('aria-live', this.options.ariaLive)
                }

                // Adding the toast message/node
                if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
                    // If we have a valid node, we insert it
                    divElement.appendChild(this.options.node)
                } else {
                    if (this.options.escapeMarkup) {
                        divElement.innerText = this.options.text;
                    } else {
                        divElement.innerHTML = this.options.text;
                    }

                    if (this.options.avatar !== "") {
                        var avatarElement = document.createElement("img");
                        avatarElement.src = this.options.avatar;

                        avatarElement.className = "toastify-avatar";

                        if (this.options.position == "left" || this.options.positionLeft === true) {
                            // Adding close icon on the left of content
                            divElement.appendChild(avatarElement);
                        } else {
                            // Adding close icon on the right of content
                            divElement.insertAdjacentElement("afterbegin", avatarElement);
                        }
                    }
                }

                // Adding a close icon to the toast
                if (this.options.close === true) {
                    // Create a span for close element
                    var closeElement = document.createElement("button");
                    closeElement.type = "button";
                    closeElement.setAttribute("aria-label", "Close");
                    closeElement.className = "toast-close";
                    closeElement.innerHTML = "&#10006;";

                    // Triggering the removal of toast from DOM on close click
                    closeElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this.removeElement(this.toastElement);
                        window.clearTimeout(this.toastElement.timeOutValue);
                    }.bind(this));

                    //Calculating screen width
                    var width = window.innerWidth > 0
                        ? window.innerWidth
                        : screen.width;

                    // Adding the close icon to the toast element
                    // Display on the right if screen width is less than or equal to 360px
                    if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
                        // Adding close icon on the left of content
                        divElement.insertAdjacentElement("afterbegin", closeElement);
                    } else {
                        // Adding close icon on the right of content
                        divElement.appendChild(closeElement);
                    }
                }

                // Clear timeout while toast is focused
                if (this.options.stopOnFocus && this.options.duration > 0) {
                    var self = this;
                    // stop countdown
                    divElement.addEventListener("mouseover", function (event) {
                        window.clearTimeout(divElement.timeOutValue);
                    })
                    // add back the timeout
                    divElement.addEventListener("mouseleave", function () {
                        divElement.timeOutValue = window.setTimeout(function () {
                            // Remove the toast from DOM
                            self.removeElement(divElement);
                        }, self.options.duration)
                    })
                }

                // Adding an on-click destination path
                if (typeof this.options.destination !== "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        if (this.options.newWindow === true) {
                            window.open(this.options.destination, "_blank");
                        } else {
                            window.location = this.options.destination;
                        }
                    }.bind(this));
                }

                if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this
                            .options
                            .onClick();
                    }.bind(this));
                }

                // Adding offset
                if (typeof this.options.offset === "object") {

                    var x = getAxisOffsetAValue("x", this.options);
                    var y = getAxisOffsetAValue("y", this.options);

                    var xOffset = this.options.position == "left"
                        ? x
                        : "-" + x;
                    var yOffset = this.options.gravity == "toastify-top"
                        ? y
                        : "-" + y;

                    divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";

                }

                // Returning the generated element
                return divElement;
            },

            // Displaying the toast
            showToast: function () {
                // Creating the DOM object for the toast
                this.toastElement = this.buildToast();

                // Getting the root element to with the toast needs to be added
                var rootElement;
                if (typeof this.options.selector === "string") {
                    rootElement = document.getElementById(this.options.selector);
                } else if (this.options.selector instanceof HTMLElement || (typeof ShadowRoot !== 'undefined' && this.options.selector instanceof ShadowRoot)) {
                    rootElement = this.options.selector;
                } else {
                    rootElement = document.body;
                }

                // Validating if root element is present in DOM
                if (!rootElement) {
                    throw "Root element is not defined";
                }

                // Adding the DOM element
                var elementToInsert = Toastify.defaults.oldestFirst
                    ? rootElement.firstChild
                    : rootElement.lastChild;
                rootElement.insertBefore(this.toastElement, elementToInsert);

                // Repositioning the toasts in case multiple toasts are present
                Toastify.reposition();

                if (this.options.duration > 0) {
                    this.toastElement.timeOutValue = window.setTimeout(function () {
                        // Remove the toast from DOM
                        this.removeElement(this.toastElement);
                    }.bind(this), this.options.duration); // Binding `this` for function invocation
                }

                // Supporting function chaining
                return this;
            },

            hideToast: function () {
                if (this.toastElement.timeOutValue) {
                    clearTimeout(this.toastElement.timeOutValue);
                }
                this.removeElement(this.toastElement);
            },

            // Removing the element from the DOM
            removeElement: function (toastElement) {
                // Hiding the element
                // toastElement.classList.remove("on");
                toastElement.className = toastElement
                    .className
                    .replace(" on", "");

                // Removing the element from DOM after transition end
                window.setTimeout(function () {
                    // remove options node if any
                    if (this.options.node && this.options.node.parentNode) {
                        this
                            .options
                            .node
                            .parentNode
                            .removeChild(this.options.node);
                    }

                    // Remove the element from the DOM, only when the parent node was not removed before.
                    if (toastElement.parentNode) {
                        toastElement
                            .parentNode
                            .removeChild(toastElement);
                    }

                    // Calling the callback function
                    this
                        .options
                        .callback
                        .call(toastElement);

                    // Repositioning the toasts again
                    Toastify.reposition();
                }.bind(this), 400); // Binding `this` for function invocation
            }
        };

        // Positioning the toasts on the DOM
        Toastify.reposition = function () {

            // Top margins with gravity
            var topLeftOffsetSize = {
                top: 15,
                bottom: 15
            };
            var topRightOffsetSize = {
                top: 15,
                bottom: 15
            };
            var offsetSize = {
                top: 15,
                bottom: 15
            };

            // Get all toast messages on the DOM
            var allToasts = document.getElementsByClassName("toastify");

            var classUsed;

            // Modifying the position of each toast element
            for (var i = 0; i < allToasts.length; i++) {
                // Getting the applied gravity
                if (containsClass(allToasts[i], "toastify-top") === true) {
                    classUsed = "toastify-top";
                } else {
                    classUsed = "toastify-bottom";
                }

                var height = allToasts[i].offsetHeight;
                classUsed = classUsed.substr(9, classUsed.length - 1)
                // Spacing between toasts
                var offset = 15;

                var width = window.innerWidth > 0
                    ? window.innerWidth
                    : screen.width;

                // Show toast in center if screen with less than or equal to 360px
                if (width <= 360) {
                    // Setting the position
                    allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";

                    offsetSize[classUsed] += height + offset;
                } else {
                    if (containsClass(allToasts[i], "toastify-left") === true) {
                        // Setting the position
                        allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";

                        topLeftOffsetSize[classUsed] += height + offset;
                    } else {
                        // Setting the position
                        allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";

                        topRightOffsetSize[classUsed] += height + offset;
                    }
                }
            }

            // Supporting function chaining
            return this;
        };

        // Helper function to get offset.
        function getAxisOffsetAValue(axis, options) {

            if (options.offset[axis]) {
                if (isNaN(options.offset[axis])) {
                    return options.offset[axis];
                } else {
                    return options.offset[axis] + 'px';
                }
            }

            return '0px';

        }

        function containsClass(elem, yourClass) {
            if (!elem || typeof yourClass !== "string") {
                return false;
            } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
                return true;
            } else {
                return false;
            }
        }

        // Setting up the prototype for the init object
        Toastify.lib.init.prototype = Toastify.lib;

        // Returning the Toastify function to be assigned to the window object/module
        return Toastify;
    });
</script>
    <style>
  :root {
    --base-font-family: "Calluna", Georgia, serif;
    --base-font-size: 18px;
    --small-font-size: var(--base-font-size) * 0.875;
    --base-line-height: 1.5;
    --spacing-unit: 30px;
    --spacing-unit-line: 7px;
    --text-color: #181818;
    --background-color: #fdfdfd;
    --brand-color: #4d96b9;
    --brand-color-secondary: #109269;
    --brand-color-light: lighten(var(--brand-color-secondary), 1%);
    --brand-color-dark: darken(var(--brand-color-secondary), 1%);
    --grey-color: #141414;
    --grey-color-light: lighten(var(--grey-color), 20%);
    --grey-color-dark: darken(var(--grey-color), 15%);
    --on-palm: 750px;
    --on-laptop: 800px;
    --statblock-main-color: #7a200d;
    --statblock-secondary-color: #922610;
    --statblock-background-color: #fdf1dc;
    --toastContainerTop: auto;
    --toastContainerRight: auto;
    --toastContainerBottom: 8rem;
    --toastContainerLeft: calc(50vw - 8rem);
  }

  a {
    color: blue;
    cursor: pointer;
  }

  .stat-header {
    margin-bottom: 1em;
    margin-top: 1em;
  }
  .stat-value {
    font-size: 20px;
  }

  .stat-block {
    font-size: 13.5px;
    line-height: 1.2em;
    box-sizing: border-box;
    max-width: 100%;
    text-align: left;
    vertical-align: top;
    width: 50%;
    min-width: 280px;
    background: var(--statblock-background-color);
    padding: 5px 10px 20px;
    box-shadow: 0 0 1.5em #867453;
    margin-top: 20px;
    margin-bottom: 10px;
    margin-right: auto;
    margin-left: auto;
  }
  .stat-block p {
    margin-bottom: 10px;
  }
  .stat-block h4 {
    font-weight: bold;
  }
  .orange-border {
    display: block;
    background: #e69a28;
    border: 1px solid #000;
    height: 5px;
    padding: 0 10px 0;
    margin: -10px -10px 0;
    box-sizing: initial;
  }
  .orange-border.bottom {
    margin: 15px -10px -20px;
  }
  .tapered-rule {
    display: block;
    width: 100%;
    height: 5px;
    border: none;
    color: var(--statblock-secondary-color);
    fill: var(--statblock-secondary-color);
    stroke: var(--statblock-secondary-color);
  }
  .top-gap {
    margin: 0 0 8px;
  }
  .bottom-gap {
    margin: 10px 0;
  }
  .creature-heading h1 {
    color: var(--statblock-secondary-color);
    font-size: 23px;
    line-height: 1.2em;
    margin: 10px 0 0;
    letter-spacing: 1px;
    font-variant: small-caps;
    font-weight: bold;
  }
  .creature-heading h2 {
    font-weight: normal;
    font-style: italic;
    font-size: 12px;
    line-height: 1.2em;
    margin: 0 0 10px;
  }
  .property-line h4,
  .property-line p {
    display: inline;
    margin: 0;
    color: var(--statblock-secondary-color);
    font-size: 13.5px;
    line-height: 1.2em;
  }
  .property-line h4 {
    color: var(--statblock-main-color);
  }
  .property-line {
    text-indent: -1em;
    padding-left: 1.1em;
    line-height: 1.4em;
  }
  .property-line.first {
    margin: 8px 0 0;
  }
  .property-line.last {
    margin: 0 0 10px;
  }
  .abilities {
    text-align: center;
    color: var(--statblock-secondary-color);
    margin-bottom: 1em;
  }
  .abilities > div {
    display: inline-block;
    vertical-align: middle;
    width: 12.5%;
    min-width: 40px;
    font-size: 12px;
    line-height: 1em;
  }
  #actions > *,
  #reactions > * {
    border-bottom: 1px solid var(--statblock-main-color);
    color: var(--statblock-main-color);
    font-size: 14px;
    font-weight: normal;
    margin: 10px 0 0;
    padding: 0 0 10px;
    text-indent: 5px;
  }
  #actions,
  #reactions {
    margin: 0 0 10px;
  }
  #actions:last-child,
  #reactions:last-child {
    margin: 0;
  }

  @media print {
    .orange-border {
      display: none;
    }
    .stat-block,
    .property-line,
    .stat-block {
      width: 40%;
      display: inline-block;
      vertical-align: top;
    }
  }
  @media screen and (max-width: 575px) {
    .stat-block {
      /* margin: 5px; */
      width: 100%;
    }
  }

.toastify {
    padding: 12px 20px;
    color: #ffffff;
    display: inline-block;
    box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);
    background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);
    background: linear-gradient(135deg, #73a5ff, #5477f5);
    position: fixed;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
    border-radius: 2px;
    cursor: pointer;
    text-decoration: none;
    max-width: calc(50% - 20px);
    z-index: 2147483647;
}

.toastify.on {
    opacity: 1;
}

.toast-close {
    background: transparent;
    border: 0;
    color: white;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    opacity: 0.4;
    padding: 0 5px;
}

.toastify-right {
    right: 15px;
}

.toastify-left {
    left: 15px;
}

.toastify-top {
    top: -150px;
}

.toastify-bottom {
    bottom: -150px;
}

.toastify-rounded {
    border-radius: 25px;
}

.toastify-avatar {
    width: 1.5em;
    height: 1.5em;
    margin: -7px 5px;
    border-radius: 2px;
}

.toastify-center {
    margin-left: auto;
    margin-right: auto;
    left: 0;
    right: 0;
    max-width: fit-content;
    max-width: -moz-fit-content;
}

@media only screen and (max-width: 360px) {
    .toastify-right, .toastify-left {
        margin-left: auto;
        margin-right: auto;
        left: 0;
        right: 0;
        max-width: fit-content;
    }
}
</style>

</html>