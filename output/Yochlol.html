<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yochlol</title>
</head>
    <body>
        <div class="post">
  <div class="stat-block">
    <hr class="orange-border"/>
    <div class="section-left">
      <div class="creature-heading">
        <div style="display:flex; justify-content:space-between;">
          <h1>Yochlol</h1>
        </div>
        <h2 style="color:black;">M, Chaotic Evil</h2>
      </div>
      <!-- creature heading -->
      <svg height="5" width="100%" class="tapered-rule">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div class="top-stats">
  <!-- property line -->
  <div class="property-line">
    <h4>Hit Points</h4>
    <div >
      <input type="text" style="width:2em;" value=136 (16d8+64)></input>
      <p>136 (16d8+64)</p>
    </div>
  </div>
  <!-- property line -->
  <div class="property-line first">
    <h4>Armor Class:</h4>
    <p>15 (natural armor)</p>
  </div>
  <div class="property-line last">
    <h4>Speed:</h4>
    <p>walk 30 ft., climb 30 ft.</p>
  </div>
  <!-- property line -->
  <svg height="5" width="100%" class="tapered-rule">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  <div class="abilities">
    <div>
      <div class="stat-header">
        <b class="stat-value">STR</b>
      </div>
      15 <a class='roll'>+2</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">DEX</b>
      </div>
      14 <a class='roll'>+2</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CON</b>
      </div>
      18 <a class='roll'>+4</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">WIS</b>
      </div>
      15 <a class='roll'>+2</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">INT</b>
      </div>
      13 <a class='roll'>+1</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CHA</b>
      </div>
      15 <a class='roll'>+2</a>
    </div>
  </div>
  <svg height="5" width="100%" class="tapered-rule top-gap">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  
    <div class="property-line">
      <h4>Damage Immunities:</h4>
      <p>poison</p>
    </div>
    

    
      <div class="property-line">
        <h4>Damage Resistances:</h4>
        <p>cold, fire, lightning; bludgeoning, piercing, slashing from nonmagical attacks</p>
      </div>
      

      

        
          <div class="property-line">
            <h4>Condition Immunities:</h4>
            <p>poisoned</p>
          </div>
          

          
            <div class="property-line">
              <h4>Senses:</h4>
              <p>darkvision 120 ft.</p>
            </div>
            

            
              <div class="property-line">
                <h4>Saving Throws:</h4>
                <p>
                  Dex <a class='roll'>+6</a>, Int <a class='roll'>+5</a>, Wis <a class='roll'>+6</a>, Cha <a class='roll'>+6</a>
                </p>
              </div>
              

              
                <div class="property-line">
                  <h4>Skills:</h4>
                  <p>
                    Deception <a class='roll'>+10</a>, Insight <a class='roll'>+6</a>
                  </p>
                </div>
                

                
                  <div class="property-line">
                    <h4>Languages:</h4>
                    <p>Abyssal, Elvish, Undercommon</p>
                  </div>
                  

                  

                    
                      <div class="property-line">
                        <h4>Challenge:</h4>
                        <p>10</p>
                      </div>
                      

                      

                      </div>
      <svg height="5" width="100%" class="tapered-rule bottom-gap">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div id="actions">
    
        <div class="creature-heading">
            <h1>Traits</h1>
        </div>
        <div>
            
                <div>
                    <b>Shapechanger: </b>
                    <span>The yochlol can use its action to polymorph into a form that resembles a female drow or giant spider, or back into its true form. Its statistics are the same in each form. Any equipment it is wearing or carrying isn't transformed. It reverts to its true form if it dies.</span>
                </div>
                <br/>
                
                <div>
                    <b>Magic Resistance: </b>
                    <span>The yochlol has advantage on saving throws against spells and other magical effects.</span>
                </div>
                <br/>
                
                <div>
                    <b>Spider Climb: </b>
                    <span>The yochlol can climb difficult surfaces, including upside down on ceilings, without needing to make an ability check.</span>
                </div>
                <br/>
                
                <div>
                    <b>Web Walker: </b>
                    <span>The yochlol ignores movement restrictions caused by webbing.</span>
                </div>
                <br/>
                
                <div>
                    <b>Innate Spellcasting: </b>
                    <span>The yochlol's spellcasting ability is Charisma (spell save DC 14). The yochlol can innately cast the following spells, requiring no material components:,At will: detect thoughts, web,1/day: dominate person</span>
                </div>
                <br/>
                
            </div>
        </div>
        
        
            <div id="actions">
                <div class="creature-heading">
                    <h1>Actions</h1>
                </div>
                <div>
                    
                        <div>
                            <b>Multiattack: </b>
                            <span>The yochlol makes two melee attacks.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Slam (Bite in Spider Form): </b>
                            <span>Melee Weapon Attack: <a class='roll'>+6</a> to hit, reach 5 ft. (10 feet in demon form), one target. 5 <a class='roll'>(1d6 + 2)</a> bludgeoning (piercing in spider form) damage plus 21 <a class='roll'>(6d6)</a> poison damage.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Mist Form: </b>
                            <span>The yochlol transforms into toxic mist or reverts to its true form. Any equipment it is wearing or carrying is also transformed. It reverts to its true form if it dies.,While in mist form, the yochlol is incapacitated and can't speak. It has a flying speed of 30 feet, can hover, and can pass through any space that isn't airtight. It has advantage on Strength, Dexterity, and Constitution saving throws, and it is immune to nonmagical damage.,While in mist form, the yochlol can enter a creature's space and stop there. Each time that creature starts its turn with the yochlol in its space, the creature must succeed on a DC 14 Constitution saving throw or be poisoned until the start of its next turn. While poisoned in this way, the target is incapacitated.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Variant: Summon Demon (1/Day): </b>
                            <span>The demon chooses what to summon and attempts a magical summoning.,A yochlol has a 50 chance of summoning one yochlol.,A summoned demon appears in an unoccupied space within 60 feet of its summoner, acts as an ally of its summoner, and can't summon other demons. It remains for 1 minute, until it or its summoner dies, or until its summoner dismisses it as an action.</span>
                        </div>
                        <br/>
                        
                        <br/>
                    </div>
                </div>
                
                
                        

      <div id="reactions">
        <div class="creature-heading">
          <h1>
              Description
          </h1>
        </div>
        <p>Spawn of Chaos. The Abyss creates demons as extensions of itself, spontaneously forming fiends out of filth and carnage. Some are unique monstrosities, while others represent uniform strains virtually identical to each other. Other demons (such as manes) are created from mortal souls shunned or cursed by the gods, or which are otherwise trapped in the Abyss.
Capricious Elevation. Demons respect power and power alone. A greater demon commands shrieking mobs of lesser demons because it can destroy any lesser demon that dares to refuse its commands. A demon's status grows with the blood it spills; the more enemies that fall before it, the greater it becomes.
A demon might spawn as a manes, then become a dretch, and eventually transform to a vrock after untold time spent fighting and surviving in the Abyss. Such elevations are rare, however, for most demons are destroyed before they attain significant power. The greatest of those that do survive make up the ranks of the demon lords that threaten to tear the Abyss apart with their endless warring.
By expending considerable magical power, demon lords can raise lesser demons into greater forms, though such promotions never stem from a demon's deeds or accomplishments. Rather, a demon lord might warp a manes into a quasit when it needs an invisible spy, or turn an army of dretches into hezrous when marching against a rival lord. Demon lords only rarely elevate demons to the highest ranks, fearful of inadvertently creating rivals to their own power.
Abyssal Invasions. Wherever they wander across the Abyss, demons search for portals to the other planes. They crave the chance to slip free of their native realm and spread their dark influence across the multiverse, undoing the works of the gods, tearing down civilizations, and reducing the cosmos to despair and ruin.
Some of the darkest legends of the mortal realm are built around the destruction wrought by demons set loose in the world. As such, even nations embroiled in bitter conflict will set their differences aside to help contain an outbreak of demons, or to seal off abyssal breaches before these fiends can break free.
Signs of Corruption. Demons carry the stain of abyssal corruption with them, and their mere presence changes the world for the worse. Plants wither and die in areas where abyssal breaches and demons appear. Animals shun the sites where a demon has made a kill. The site of a demonic infestation might be fouled by a stench that never abates, by areas of bitter cold or burning heat, or by permanent shadows that mark the places where these fiends lingered.
Eternal Evil. Outside the Abyss, death is a minor nuisance that no demon fears. Mundane weapons can't stop these fiends, and many demons are resistant to the energy of the most potent spells. When a lucky hero manages to drop a demon in combat, the fiend dissolves into foul ichor. It then instantly reforms in the Abyss, its mind and essence intact even as its hatred is inflamed.
The only way to truly destroy a demon is to seek it in the Abyss and kill it there.
Protected Essence. A powerful demon can take steps to safeguard its life essence, using secret methods and abyssal metals to create an amulet into which part of that essence is ceded. If the demon's abyssal form is ever destroyed, the amulet allows the fiend to reform at a time and place of its choosing.
Obtaining a demonic amulet is a dangerous enterprise, and simply seeking such a device risks drawing the attention of the demon that created it. A creature possessing a demonic amulet can exact favors from the demon whose life essence the amulet holds—or inflict great pain if the fiend resists. If an amulet is destroyed, the demon that created it is trapped in the Abyss for a year and a day.
Demonic Cults. Despite the dark risks involved in dealing with fiends, the mortal realm is filled with creatures that covet demonic power. Demon lords manipulate these mortal servants into performing ever greater acts of depravity, furthering the demon lord's ambitions in exchange for magic and other boons. However, a demon regards any mortals in its service as tools to use and then discard at its whim, consigning their mortal souls to the Abyss.
Demon Summoning. Few acts are as dangerous as summoning a demon, and even mages who bargain freely with devils fear the fiends of the Abyss. Though demons yearn to sow chaos on the Material Plane, they show no gratitude when brought there, raging against their prisons and demanding release.
Those who would risk summoning a demon might do so to wrest information from it, press it into service, or send it on a mission that only a creature of absolute evil can complete. Preparation is key, and experienced summoners know the specific spells and magic items that can force a demon to bend to another's will. If a single mistake is made, a demon that breaks free shows no mercy as it makes its summoner the first victim of its wrath.
Bound Demons. The Book of Vile Darkness, the Black Scrolls of Ahm, and the Demonomicon of Iggwilv are the foremost authorities on demonic matters. These ancient tomes describe techniques that can trap the essence of a demon on the Material Plane, placing it within a weapon, idol, or piece of jewelry and preventing the fiend's return to the Abyss.
An object that binds a demon must be specially prepared with unholy incantations and innocent blood. It radiates a palpable evil, chilling and fouling the air around it. A creature that handles such an object experiences unsettling dreams and wicked impulses, but is able to control the demon whose essence is trapped within the object. Destroying the object frees the demon, which immediately seeks revenge against its binder.
Demonic Possession. No matter how secure its bindings, a powerful demon often finds a way to escape an object that holds it. When a demonic essence emerges from its container, it can possess a mortal host. Sometimes a fiend employs stealth to hide a successful possession. Other times, it unleashes the full brunt of its fiendish drives through its new form.
As long as the demon remains in possession of its host, the soul of that host is in danger of being dragged to the Abyss with the demon if it is exorcised from the flesh, or if the host dies. If a demon possesses a creature and the object binding the demon is destroyed, the possession lasts until powerful magic is used to drive the demonic spirit out of its host.
Demon Lords
The chaotic power of the Abyss rewards demons of particular ruthlessness and ingenuity with a dark blessing, transforming them into unique fiends whose power can rival the gods. These demon lords rule through cunning or brute force, hoping to one day claim the prize of absolute control over all the Abyss.
Reward for Outsiders. Although most demon lords rise up from the vast and uncountable mobs of demons rampaging across the Abyss, the plane also rewards outsiders that conquer any of its infinite layers. The elven goddess Lolth became a demon lord after Corellon Larethian cast her into the Abyss for betraying elvenkind. Sages claim that the Dark Prince Graz'zt originated on some other plane before stealing his abyssal title from another long-forgotten demon lord.
Power and Control. The greatest sign of a demon lord's power is its ability to reshape an abyssal realm. A layer of the Abyss controlled by a demon lord becomes a twisted reflection of that fiend's vile personality, and demon lords seldom leave their realms for fear of allowing another creature to reshape and seize it.
As with other demons, a demon lord that dies on another plane has its essence return to the Abyss, where it reforms into a new body. Likewise, a demon lord that dies in the Abyss is permanently destroyed. Most demon lords keep a portion of their essence safely stored away to prevent such a fate.
Baphomet. The demon lord Baphomet, also known as the Horned King and the Prince of Beasts, rules over minotaurs and other savage creatures. If he had his way, civilization would crumble and all races would embrace their base animal savagery.
The Prince of Beasts appears as a huge, black-furred minotaur with iron horns, red eyes, and a blood-soaked mouth. His iron crown is topped with the rotting heads of his enemies, while his dark armor is set with spikes and skull-like serrations. He carries a huge glaive named Heartcleaver, but often hurls it into the fray so as to face his enemies with horns and hooves.
Demogorgon. The Sibilant Beast and the self-styled Prince of Demons, Demogorgon yearns for nothing less than undoing the order of the multiverse. An insane assemblage of features and drives, the Prince of Demons inspires fear and hatred among other demons and demon lords.
Demogorgon towers three times the height of a human, his body as sinuous as a snake's and as powerful as a great ape's. Suckered tentacles take the place of his arms. His saurian lower torso ends in webbed and clawed feet, and a forked tail whose whip-like tips are armed with cruel blades. The Prince of Demons has two baleful baboon heads, both of them mad. It is only the conflict between the two halves of his dual nature that keeps the demon lord's ambitions in check.
Graz'zt. The demon lord Graz'zt appears as a darkly handsome figure nearly nine feet tall. Those who refer to the Dark Prince as the most humanoid of the demon lords vastly underestimate the capacity for evil in his scheming heart.
Graz'zt is a striking physical specimen, whose demonic nature shows in his ebon skin, pointed ears, yellow fangs, crown of horns, and six-fingered hands. He delights in finery, pageantry, and sating his decadent desires with subjects and consorts alike, among whom incubi and succubi are often his favorites.
Juiblex. The demon lord of slimes and oozes, Juiblex is a stew of noxious fluids that lurks in the abyssal depths. The wretched Faceless Lord cares nothing for cultists or mortal servants, and its sole desire is to turn all creatures into formless copies of its horrid self.
In its resting state, Juiblex spreads out in a noxious mass, bubbling and filling the air with a profound stench. On the rare occasions when creatures confront the demon lord, Juiblex draws itself up into a shuddering cone of slime striated with veins of black and green. Baleful red eyes swim within its gelatinous body, while dripping pseudopods of ooze lash out hungrily at any creature they can reach.
Lolth. The Demon Queen of Spiders is the evil matron of the drow. Her every thought is touched by malice, and the depth of her viciousness can surprise even her most faithful priestesses. She directs her faithful while she weaves plots across the worlds of the Material Plane, looking forward to the time when her drow followers bring those worlds under her control.
Lolth appears as a lithe, imperious drow matriarch when she manifests to her followers in the mortal realm, which she does with unusual frequency. When battle breaks out-or if she has a reason to remind her followers to fear her—Lolth's lower body transforms into that of a huge demonic spider, whose spike—tipped legs and mandibles tear foes apart.
Orcus. Known as the Demon Prince of Undeath and the Blood Lord, the demon lord Orcus is worshiped by the undead and by living creatures that channel the power of undeath. A brooding and nihilistic entity, Orcus yearns to make the multiverse a place of death and darkness, forever unchanging except by his will.
The Demon Prince of Undeath is a foul and corpulent creature, with a humanoid torso, powerful goat legs, and the desiccated head of a ram. His sore-ridden body stinks of disease, but his decaying head and glowing red eyes are as a creature already dead. Great black bat wings sprout from his back, stirring reeking air as he moves.
Orcus wields a malevolent artifact known as the Wand of Orcus, a mace-like rod of obsidian topped by a humanoid skull. He surrounds himself with undead, and living creatures not under his control are anathema to him.
Yeenoghu. Known as the Gnoll Lord and the Beast of Butchery, the demon lord Yeenoghu hungers for slaughter and senseless destruction. Gnolls are his mortal instruments, and he drives them to ever-greater atrocities in his name. Delighting in sorrow and hopelessness, the Gnoll Lord yearns to turn the world into a wasteland in which the last surviving gnolls tear each other apart for the right to feast upon the dead.
Yeenoghu appears as a huge, scarred gnoll with a spiky crest of black spines, and eyes that burn with emerald flame. His armor is a patchwork of shields and breastplates claimed from fallen foes, and decorated by those foes' flayed skins. Yeenoghu can summon a triple flail he calls the Butcher, which he wields to deadly effect or wills to fly independently into battle as he tears foes apart with teeth and claws.
Other Demon Lords. No one knows the full number of demon lords that rage in the Abyss. Given the infinite depths of that plane, powerful demons constantly rise to become demon lords, then fall almost as quickly. Among the demon lords whose power has endured long enough for demonologists to name them are Fraz-Urb'luu, the Prince of Deception; Kostchtchie, the Prince of Wrath; Pazuzu, Prince of the Lower Aerial Kingdoms; and Zuggtmoy, Lady of Fungi.
Demon Types. Demonologists organize the chaotic distribution of demons into broad categories of power known as types. Most demons fit into one of six major types, with the weakest categorized as Type 1 and the strongest as Type 6. Demons outside the six main types are categorized as minor demons and demon lords.
Demons by Type
Type | Examples
1 | barlgura, shadow demon, vrock
2 | chasme, hezrou
3 | glabrezu, yochlol
4 | nalfeshnee
5 | marilith
6 | balor, goristro

Demon True Names. 
------
Though demons all have common names, every demon lord and every demon of type 1 through 6 has a true name that it keeps secret. A demon can be forced to disclose its true name if charmed, and ancient scrolls and tomes are said to exist that list the true names of the most powerful demons.
A mortal who learns a demon's true name can use powerful summoning magic to call the demon from the Abyss and exercise some measure of control over it. However, most demons brought to the Material Plane in this manner do everything in their power to wreak havoc or sow discord and strife.
------
Variant: Demon Summoning. 
------
Some demons can have an action option that allows them to summon other demons. Summon Demon (1/Day). The demon chooses what to summon and attempts a magical summoning.
• A balor has a 50 percent chance of summoning 1d8 vrocks, 1d6 hezrous, 1d4 glabrezus, 1d3 nalfeshnees, 1d2 mariliths, or one goristro.
• A barlgura has a 30 percent chance of summoning one barlgura.
• A chasme has a 30 percent chance of summoning one chasme.
• A glabrezu has a 30 percent chance of summoning 1d3 vrocks, 1d2 hezrous, or one glabrezu.
• A hezrou has a 30 percent chance of summoning 2d6 dretches or one hezrou.
• A marilith has a 50 percent chance of summoning 1d6 vrocks, 1d4 hezrous, 1d3 glabrezus, 1d2 nalfeshnees, or one marilith.
• A nalfeshnee has a 50 percent chance of summoning 1d4 vrocks, 1d3 hezrous, 1d2 glabrezus, or one nalfeshnee.
• A vrock has a 30 percent chance of summoning 2d4 dretches or one vrock.
• A yochlol has a 50 percent chance of summoning one yochlol.
A summoned demon appears in an unoccupied space within 60 feet of its summoner, acts as an ally of its summoner, and can't summon other demons. It remains for 1 minute, until it or its summoner dies, or until its summoner dismisses it as an action.
------
Source: Monster Manual p. 65, Waterdeep: Dungeon of the Mad Mage, Explorer's Guide to Wildemount</p>
      </div>
      <hr class="orange-border bottom"/>
    </div>
  </div>
</div>
    </body>
    <script>

    function findToHit(dataString) {
        const pattern = /\+(\d{1,2}) to hit/
        let match = dataString.match(pattern)
        if (match !== null) {
            match = match[1]
        }
        return {
            "exists": match !== null,
            "value": parseInt(match)
        }
    }

    function findDamageStrings(dataString) {
        if (typeof dataString === "string") {
            let damageStrings = []
            // const toHitPattern = /\+(\d{1,2}) to hit/
            const toHitPattern = /\+(\d{1,2})/g
            const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/g
            let damageMatches = dataString.matchAll(damagePattern)
            let toHitMatches = dataString.matchAll(toHitPattern)
            for (let match of toHitMatches) {
                if (toHitMatches !== null) {
                    damageStrings.push(match[0])
                }
            }
            for (let match of damageMatches) {
                if (match !== null) {
                    damageStrings.push(match[0])
                }
            }
            return damageStrings
        }
        return []
    }

    function extractRoll(dataString) {
        const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/
        const toHitPattern = /\+(\d{1,2})/
        let damageMatch = dataString.match(damagePattern)
        let toHitMatch = dataString.match(toHitPattern)
        if (toHitMatch !== null) {
            return {"num": 1, "sides": 20, "mod": toHitMatch[1]}
        }
        if (damageMatch !== null) {
            return {"num": damageMatch[1], "sides": damageMatch[2], "mod": damageMatch[3]}
        }
    }

    function randomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + 1);
    }

    function generateRollText(num, sides, mod) {
        let output = []
        let total = 0
        for (let i = 0; i < num; i++) {
            let roll = randomNumber(1, sides)
            total += roll
            output.push(roll)
            output.push("+")
        }
        output.pop()
        if (mod >= 0 && mod !== "") {
            output.push("+")
            output.push(`(${mod})`)
            total += parseInt(mod) || 0
        } else {
            if (mod !== "") {
                output.push("+")
                output.push(`(${mod})`)
                total += parseInt(mod) || 0
            }
        }
        output.push(` = ${total}`)
        return output.join(" ")
    }

    function splitAroundRoll(dataString, patternMatches) {
        let outPut = []
        let currentPosition = 0
        for (let match of patternMatches) {
            let matchLength = match.length
            let matchStartingPosition = dataString.indexOf(match, currentPosition)
            let matchEndingPosition = matchStartingPosition + matchLength
            outPut.push({
                "value": dataString.slice(currentPosition, matchStartingPosition),
                "replace": false
            })
            currentPosition = matchEndingPosition
            outPut.push({"value": match, "replace": true})
        }
        outPut.push({"value": dataString.slice(currentPosition), "replace": false})
        return outPut;
    }

    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }

    function findSpells(traitText, spell_list) {
        let outPutList = [];
        let wordArray = traitText.split(",")
        for (let word of wordArray) {
            if (word.includes(":")) {
                word = word.slice(word.indexOf(":") + 1)
            }
            if (spell_list.includes(word.trim())) {
                outPutList.push(word)
            }
        }
        return outPutList
    }

    function addSpellIds(chunks, spell_list) {
        for (let chunk of chunks) {
            if (chunk.replace) {
                if (chunk.value.includes(":")) {
                    chunk.value = chunk
                        .value
                        .slice(chunk.value.indexOf(":") + 1)
                }
                chunk["spellId"] = spell_list.indexOf(chunk.value.trim())
            }
        }
        return chunks
    }

    document.addEventListener('DOMContentLoaded', () => {
        document
            .querySelectorAll('.roll')
            .forEach(element => {
                element.addEventListener('click', () => {
                    let roll = extractRoll(element.textContent)
                    let rollText = generateRollText(roll.num, roll.sides, roll.mod);
                    Toastify({
                        text: rollText,
                        duration: 1000,
                        gravity: "bottom", // `top` or `bottom`
                        position: "center", // `left`, `center` or `right`
                        stopOnFocus: true, // Prevents dismissing of toast on hover
                    }).showToast();

                    console.log(rollText)
                });
            });
    });
    (function (root, factory) {
        if (typeof module === "object" && module.exports) {
            module.exports = factory();
        } else {
            root.Toastify = factory();
        }
    })(this, function (global) {
        // Object initialization
        var Toastify = function (options) {
                // Returning a new init object
                return new Toastify
                    .lib
                    .init(options);
            },
            // Library version
            version = "1.12.0";

        // Set the default global options
        Toastify.defaults = {
            oldestFirst: true,
            text: "Toastify is awesome!",
            node: undefined,
            duration: 3000,
            selector: undefined,
            callback: function () {},
            destination: undefined,
            newWindow: false,
            close: false,
            gravity: "toastify-top",
            positionLeft: false,
            position: '',
            backgroundColor: '',
            avatar: "",
            className: "",
            stopOnFocus: true,
            onClick: function () {},
            offset: {
                x: 0,
                y: 0
            },
            escapeMarkup: true,
            ariaLive: 'polite',
            style: {
                background: ''
            }
        };

        // Defining the prototype of the object
        Toastify.lib = Toastify.prototype = {
            toastify: version,

            constructor: Toastify,

            // Initializing the object with required parameters
            init: function (options) {
                // Verifying and validating the input object
                if (!options) {
                    options = {};
                }

                // Creating the options object
                this.options = {};

                this.toastElement = null;

                // Validating the options
                this.options.text = options.text || Toastify.defaults.text; // Display message
                this.options.node = options.node || Toastify.defaults.node; // Display content as node
                this.options.duration = options.duration === 0
                    ? 0
                    : options.duration || Toastify.defaults.duration; // Display duration
                this.options.selector = options.selector || Toastify.defaults.selector; // Parent selector
                this.options.callback = options.callback || Toastify.defaults.callback; // Callback after display
                this.options.destination = options.destination || Toastify.defaults.destination; // On-click destination
                this.options.newWindow = options.newWindow || Toastify.defaults.newWindow; // Open destination in new window
                this.options.close = options.close || Toastify.defaults.close; // Show toast close icon
                this.options.gravity = options.gravity === "bottom"
                    ? "toastify-bottom"
                    : Toastify.defaults.gravity; // toast position - top or bottom
                this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft; // toast position - left or right
                this.options.position = options.position || Toastify.defaults.position; // toast position - left or right
                this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor; // toast background color
                this.options.avatar = options.avatar || Toastify.defaults.avatar; // img element src - url or a path
                this.options.className = options.className || Toastify.defaults.className; // additional class names for the toast
                this.options.stopOnFocus = options.stopOnFocus === undefined
                    ? Toastify.defaults.stopOnFocus
                    : options.stopOnFocus; // stop timeout on focus
                this.options.onClick = options.onClick || Toastify.defaults.onClick; // Callback after click
                this.options.offset = options.offset || Toastify.defaults.offset; // toast offset
                this.options.escapeMarkup = options.escapeMarkup !== undefined
                    ? options.escapeMarkup
                    : Toastify.defaults.escapeMarkup;
                this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
                this.options.style = options.style || Toastify.defaults.style;
                if (options.backgroundColor) {
                    this.options.style.background = options.backgroundColor;
                }

                // Returning the current object for chaining functions
                return this;
            },

            // Building the DOM element
            buildToast: function () {
                // Validating if the options are defined
                if (!this.options) {
                    throw "Toastify is not initialized";
                }

                // Creating the DOM object
                var divElement = document.createElement("div");
                divElement.className = "toastify on " + this.options.className;

                // Positioning toast to left or right or center
                if (!!this.options.position) {
                    divElement.className += " toastify-" + this.options.position;
                } else {
                    // To be depreciated in further versions
                    if (this.options.positionLeft === true) {
                        divElement.className += " toastify-left";
                        console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.')
                    } else {
                        // Default position
                        divElement.className += " toastify-right";
                    }
                }

                // Assigning gravity of element
                divElement.className += " " + this.options.gravity;

                if (this.options.backgroundColor) {
                    // This is being deprecated in favor of using the style HTML DOM property
                    console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
                }

                // Loop through our style object and apply styles to divElement
                for (var property in this.options.style) {
                    divElement.style[property] = this
                        .options
                        .style[property];
                }

                // Announce the toast to screen readers
                if (this.options.ariaLive) {
                    divElement.setAttribute('aria-live', this.options.ariaLive)
                }

                // Adding the toast message/node
                if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
                    // If we have a valid node, we insert it
                    divElement.appendChild(this.options.node)
                } else {
                    if (this.options.escapeMarkup) {
                        divElement.innerText = this.options.text;
                    } else {
                        divElement.innerHTML = this.options.text;
                    }

                    if (this.options.avatar !== "") {
                        var avatarElement = document.createElement("img");
                        avatarElement.src = this.options.avatar;

                        avatarElement.className = "toastify-avatar";

                        if (this.options.position == "left" || this.options.positionLeft === true) {
                            // Adding close icon on the left of content
                            divElement.appendChild(avatarElement);
                        } else {
                            // Adding close icon on the right of content
                            divElement.insertAdjacentElement("afterbegin", avatarElement);
                        }
                    }
                }

                // Adding a close icon to the toast
                if (this.options.close === true) {
                    // Create a span for close element
                    var closeElement = document.createElement("button");
                    closeElement.type = "button";
                    closeElement.setAttribute("aria-label", "Close");
                    closeElement.className = "toast-close";
                    closeElement.innerHTML = "&#10006;";

                    // Triggering the removal of toast from DOM on close click
                    closeElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this.removeElement(this.toastElement);
                        window.clearTimeout(this.toastElement.timeOutValue);
                    }.bind(this));

                    //Calculating screen width
                    var width = window.innerWidth > 0
                        ? window.innerWidth
                        : screen.width;

                    // Adding the close icon to the toast element
                    // Display on the right if screen width is less than or equal to 360px
                    if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
                        // Adding close icon on the left of content
                        divElement.insertAdjacentElement("afterbegin", closeElement);
                    } else {
                        // Adding close icon on the right of content
                        divElement.appendChild(closeElement);
                    }
                }

                // Clear timeout while toast is focused
                if (this.options.stopOnFocus && this.options.duration > 0) {
                    var self = this;
                    // stop countdown
                    divElement.addEventListener("mouseover", function (event) {
                        window.clearTimeout(divElement.timeOutValue);
                    })
                    // add back the timeout
                    divElement.addEventListener("mouseleave", function () {
                        divElement.timeOutValue = window.setTimeout(function () {
                            // Remove the toast from DOM
                            self.removeElement(divElement);
                        }, self.options.duration)
                    })
                }

                // Adding an on-click destination path
                if (typeof this.options.destination !== "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        if (this.options.newWindow === true) {
                            window.open(this.options.destination, "_blank");
                        } else {
                            window.location = this.options.destination;
                        }
                    }.bind(this));
                }

                if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this
                            .options
                            .onClick();
                    }.bind(this));
                }

                // Adding offset
                if (typeof this.options.offset === "object") {

                    var x = getAxisOffsetAValue("x", this.options);
                    var y = getAxisOffsetAValue("y", this.options);

                    var xOffset = this.options.position == "left"
                        ? x
                        : "-" + x;
                    var yOffset = this.options.gravity == "toastify-top"
                        ? y
                        : "-" + y;

                    divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";

                }

                // Returning the generated element
                return divElement;
            },

            // Displaying the toast
            showToast: function () {
                // Creating the DOM object for the toast
                this.toastElement = this.buildToast();

                // Getting the root element to with the toast needs to be added
                var rootElement;
                if (typeof this.options.selector === "string") {
                    rootElement = document.getElementById(this.options.selector);
                } else if (this.options.selector instanceof HTMLElement || (typeof ShadowRoot !== 'undefined' && this.options.selector instanceof ShadowRoot)) {
                    rootElement = this.options.selector;
                } else {
                    rootElement = document.body;
                }

                // Validating if root element is present in DOM
                if (!rootElement) {
                    throw "Root element is not defined";
                }

                // Adding the DOM element
                var elementToInsert = Toastify.defaults.oldestFirst
                    ? rootElement.firstChild
                    : rootElement.lastChild;
                rootElement.insertBefore(this.toastElement, elementToInsert);

                // Repositioning the toasts in case multiple toasts are present
                Toastify.reposition();

                if (this.options.duration > 0) {
                    this.toastElement.timeOutValue = window.setTimeout(function () {
                        // Remove the toast from DOM
                        this.removeElement(this.toastElement);
                    }.bind(this), this.options.duration); // Binding `this` for function invocation
                }

                // Supporting function chaining
                return this;
            },

            hideToast: function () {
                if (this.toastElement.timeOutValue) {
                    clearTimeout(this.toastElement.timeOutValue);
                }
                this.removeElement(this.toastElement);
            },

            // Removing the element from the DOM
            removeElement: function (toastElement) {
                // Hiding the element
                // toastElement.classList.remove("on");
                toastElement.className = toastElement
                    .className
                    .replace(" on", "");

                // Removing the element from DOM after transition end
                window.setTimeout(function () {
                    // remove options node if any
                    if (this.options.node && this.options.node.parentNode) {
                        this
                            .options
                            .node
                            .parentNode
                            .removeChild(this.options.node);
                    }

                    // Remove the element from the DOM, only when the parent node was not removed before.
                    if (toastElement.parentNode) {
                        toastElement
                            .parentNode
                            .removeChild(toastElement);
                    }

                    // Calling the callback function
                    this
                        .options
                        .callback
                        .call(toastElement);

                    // Repositioning the toasts again
                    Toastify.reposition();
                }.bind(this), 400); // Binding `this` for function invocation
            }
        };

        // Positioning the toasts on the DOM
        Toastify.reposition = function () {

            // Top margins with gravity
            var topLeftOffsetSize = {
                top: 15,
                bottom: 15
            };
            var topRightOffsetSize = {
                top: 15,
                bottom: 15
            };
            var offsetSize = {
                top: 15,
                bottom: 15
            };

            // Get all toast messages on the DOM
            var allToasts = document.getElementsByClassName("toastify");

            var classUsed;

            // Modifying the position of each toast element
            for (var i = 0; i < allToasts.length; i++) {
                // Getting the applied gravity
                if (containsClass(allToasts[i], "toastify-top") === true) {
                    classUsed = "toastify-top";
                } else {
                    classUsed = "toastify-bottom";
                }

                var height = allToasts[i].offsetHeight;
                classUsed = classUsed.substr(9, classUsed.length - 1)
                // Spacing between toasts
                var offset = 15;

                var width = window.innerWidth > 0
                    ? window.innerWidth
                    : screen.width;

                // Show toast in center if screen with less than or equal to 360px
                if (width <= 360) {
                    // Setting the position
                    allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";

                    offsetSize[classUsed] += height + offset;
                } else {
                    if (containsClass(allToasts[i], "toastify-left") === true) {
                        // Setting the position
                        allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";

                        topLeftOffsetSize[classUsed] += height + offset;
                    } else {
                        // Setting the position
                        allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";

                        topRightOffsetSize[classUsed] += height + offset;
                    }
                }
            }

            // Supporting function chaining
            return this;
        };

        // Helper function to get offset.
        function getAxisOffsetAValue(axis, options) {

            if (options.offset[axis]) {
                if (isNaN(options.offset[axis])) {
                    return options.offset[axis];
                } else {
                    return options.offset[axis] + 'px';
                }
            }

            return '0px';

        }

        function containsClass(elem, yourClass) {
            if (!elem || typeof yourClass !== "string") {
                return false;
            } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
                return true;
            } else {
                return false;
            }
        }

        // Setting up the prototype for the init object
        Toastify.lib.init.prototype = Toastify.lib;

        // Returning the Toastify function to be assigned to the window object/module
        return Toastify;
    });
</script>
    <style>
  :root {
    --base-font-family: "Calluna", Georgia, serif;
    --base-font-size: 18px;
    --small-font-size: var(--base-font-size) * 0.875;
    --base-line-height: 1.5;
    --spacing-unit: 30px;
    --spacing-unit-line: 7px;
    --text-color: #181818;
    --background-color: #fdfdfd;
    --brand-color: #4d96b9;
    --brand-color-secondary: #109269;
    --brand-color-light: lighten(var(--brand-color-secondary), 1%);
    --brand-color-dark: darken(var(--brand-color-secondary), 1%);
    --grey-color: #141414;
    --grey-color-light: lighten(var(--grey-color), 20%);
    --grey-color-dark: darken(var(--grey-color), 15%);
    --on-palm: 750px;
    --on-laptop: 800px;
    --statblock-main-color: #7a200d;
    --statblock-secondary-color: #922610;
    --statblock-background-color: #fdf1dc;
    --toastContainerTop: auto;
    --toastContainerRight: auto;
    --toastContainerBottom: 8rem;
    --toastContainerLeft: calc(50vw - 8rem);
  }

  a {
    color: blue;
    cursor: pointer;
  }

  .stat-header {
    margin-bottom: 1em;
    margin-top: 1em;
  }
  .stat-value {
    font-size: 20px;
  }

  .stat-block {
    font-size: 13.5px;
    line-height: 1.2em;
    box-sizing: border-box;
    max-width: 100%;
    text-align: left;
    vertical-align: top;
    width: 50%;
    min-width: 280px;
    background: var(--statblock-background-color);
    padding: 5px 10px 20px;
    box-shadow: 0 0 1.5em #867453;
    margin-top: 20px;
    margin-bottom: 10px;
    margin-right: auto;
    margin-left: auto;
  }
  .stat-block p {
    margin-bottom: 10px;
  }
  .stat-block h4 {
    font-weight: bold;
  }
  .orange-border {
    display: block;
    background: #e69a28;
    border: 1px solid #000;
    height: 5px;
    padding: 0 10px 0;
    margin: -10px -10px 0;
    box-sizing: initial;
  }
  .orange-border.bottom {
    margin: 15px -10px -20px;
  }
  .tapered-rule {
    display: block;
    width: 100%;
    height: 5px;
    border: none;
    color: var(--statblock-secondary-color);
    fill: var(--statblock-secondary-color);
    stroke: var(--statblock-secondary-color);
  }
  .top-gap {
    margin: 0 0 8px;
  }
  .bottom-gap {
    margin: 10px 0;
  }
  .creature-heading h1 {
    color: var(--statblock-secondary-color);
    font-size: 23px;
    line-height: 1.2em;
    margin: 10px 0 0;
    letter-spacing: 1px;
    font-variant: small-caps;
    font-weight: bold;
  }
  .creature-heading h2 {
    font-weight: normal;
    font-style: italic;
    font-size: 12px;
    line-height: 1.2em;
    margin: 0 0 10px;
  }
  .property-line h4,
  .property-line p {
    display: inline;
    margin: 0;
    color: var(--statblock-secondary-color);
    font-size: 13.5px;
    line-height: 1.2em;
  }
  .property-line h4 {
    color: var(--statblock-main-color);
  }
  .property-line {
    text-indent: -1em;
    padding-left: 1.1em;
    line-height: 1.4em;
  }
  .property-line.first {
    margin: 8px 0 0;
  }
  .property-line.last {
    margin: 0 0 10px;
  }
  .abilities {
    text-align: center;
    color: var(--statblock-secondary-color);
    margin-bottom: 1em;
  }
  .abilities > div {
    display: inline-block;
    vertical-align: middle;
    width: 12.5%;
    min-width: 40px;
    font-size: 12px;
    line-height: 1em;
  }
  #actions > *,
  #reactions > * {
    border-bottom: 1px solid var(--statblock-main-color);
    color: var(--statblock-main-color);
    font-size: 14px;
    font-weight: normal;
    margin: 10px 0 0;
    padding: 0 0 10px;
    text-indent: 5px;
  }
  #actions,
  #reactions {
    margin: 0 0 10px;
  }
  #actions:last-child,
  #reactions:last-child {
    margin: 0;
  }

  @media print {
    .orange-border {
      display: none;
    }
    .stat-block,
    .property-line,
    .stat-block {
      width: 40%;
      display: inline-block;
      vertical-align: top;
    }
  }
  @media screen and (max-width: 575px) {
    .stat-block {
      /* margin: 5px; */
      width: 100%;
    }
  }

.toastify {
    padding: 12px 20px;
    color: #ffffff;
    display: inline-block;
    box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);
    background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);
    background: linear-gradient(135deg, #73a5ff, #5477f5);
    position: fixed;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
    border-radius: 2px;
    cursor: pointer;
    text-decoration: none;
    max-width: calc(50% - 20px);
    z-index: 2147483647;
}

.toastify.on {
    opacity: 1;
}

.toast-close {
    background: transparent;
    border: 0;
    color: white;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    opacity: 0.4;
    padding: 0 5px;
}

.toastify-right {
    right: 15px;
}

.toastify-left {
    left: 15px;
}

.toastify-top {
    top: -150px;
}

.toastify-bottom {
    bottom: -150px;
}

.toastify-rounded {
    border-radius: 25px;
}

.toastify-avatar {
    width: 1.5em;
    height: 1.5em;
    margin: -7px 5px;
    border-radius: 2px;
}

.toastify-center {
    margin-left: auto;
    margin-right: auto;
    left: 0;
    right: 0;
    max-width: fit-content;
    max-width: -moz-fit-content;
}

@media only screen and (max-width: 360px) {
    .toastify-right, .toastify-left {
        margin-left: auto;
        margin-right: auto;
        left: 0;
        right: 0;
        max-width: fit-content;
    }
}
</style>

</html>