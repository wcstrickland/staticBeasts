<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flesh Golem</title>
</head>
    <body>
        <div class="post">
  <div class="stat-block">
    <hr class="orange-border"/>
    <div class="section-left">
      <div class="creature-heading">
        <div style="display:flex; justify-content:space-between;">
          <h1>Flesh Golem</h1>
        </div>
        <h2 style="color:black;">M, Neutral</h2>
      </div>
      <!-- creature heading -->
      <svg height="5" width="100%" class="tapered-rule">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div class="top-stats">
  <!-- property line -->
  <div class="property-line">
    <h4>Hit Points</h4>
    <div >
      <input type="text" style="width:2em;" value=93 (11d8+44)></input>
      <p>93 (11d8+44)</p>
    </div>
  </div>
  <!-- property line -->
  <div class="property-line first">
    <h4>Armor Class:</h4>
    <p>9</p>
  </div>
  <div class="property-line last">
    <h4>Speed:</h4>
    <p>walk 30 ft.</p>
  </div>
  <!-- property line -->
  <svg height="5" width="100%" class="tapered-rule">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  <div class="abilities">
    <div>
      <div class="stat-header">
        <b class="stat-value">STR</b>
      </div>
      19 <a class='roll'>+4</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">DEX</b>
      </div>
      9 -1
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CON</b>
      </div>
      18 <a class='roll'>+4</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">WIS</b>
      </div>
      10 <a class='roll'>+0</a>
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">INT</b>
      </div>
      6 -2
    </div>
    <div>
      <div class="stat-header">
        <b class="stat-value">CHA</b>
      </div>
      5 -3
    </div>
  </div>
  <svg height="5" width="100%" class="tapered-rule top-gap">
    <polyline points="0,0 400,2.5 0,5"/>
  </svg>
  
    <div class="property-line">
      <h4>Damage Immunities:</h4>
      <p>lightning, poison; bludgeoning, piercing, slashing from nonmagical attacks that aren't adamantine</p>
    </div>
    

    

      

        
          <div class="property-line">
            <h4>Condition Immunities:</h4>
            <p>charmed, exhaustion, frightened, paralyzed, petrified, poisoned</p>
          </div>
          

          
            <div class="property-line">
              <h4>Senses:</h4>
              <p>darkvision 60 ft.</p>
            </div>
            

            

              

                
                  <div class="property-line">
                    <h4>Languages:</h4>
                    <p>understands the languages of its creator but can't speak</p>
                  </div>
                  

                  

                    
                      <div class="property-line">
                        <h4>Challenge:</h4>
                        <p>5</p>
                      </div>
                      

                      

                      </div>
      <svg height="5" width="100%" class="tapered-rule bottom-gap">
        <polyline points="0,0 400,2.5 0,5"/>
      </svg>
      <div id="actions">
    
        <div class="creature-heading">
            <h1>Traits</h1>
        </div>
        <div>
            
                <div>
                    <b>Berserk: </b>
                    <span>Whenever the golem starts its turn with 40 hit points or fewer, roll a d6. On a 6, the golem goes berserk. On each of its turns while berserk, the golem attacks the nearest creature it can see. If no creature is near enough to move to and attack, the golem attacks an object, with preference for an object smaller than itself. Once the golem goes berserk, it continues to do so until it is destroyed or regains all its hit points.,The golem's creator, if within 60 feet of the berserk golem, can try to calm it by speaking firmly and persuasively. The golem must be able to hear its creator, who must take an action to make a DC 15 Charisma (Persuasion) check. If the check succeeds, the golem ceases being berserk. If it takes damage while still at 40 hit points or fewer, the golem might go berserk again.</span>
                </div>
                <br/>
                
                <div>
                    <b>Aversion of Fire: </b>
                    <span>If the golem takes fire damage, it has disadvantage on attack rolls and ability checks until the end of its next turn.</span>
                </div>
                <br/>
                
                <div>
                    <b>Immutable Form: </b>
                    <span>The golem is immune to any spell or effect that would alter its form.</span>
                </div>
                <br/>
                
                <div>
                    <b>Lightning Absorption: </b>
                    <span>Whenever the golem is subjected to lightning damage, it takes no damage and instead regains a number of hit points equal to the lightning damage dealt.</span>
                </div>
                <br/>
                
                <div>
                    <b>Magic Resistance: </b>
                    <span>The golem has advantage on saving throws against spells and other magical effects.</span>
                </div>
                <br/>
                
                <div>
                    <b>Magic Weapons: </b>
                    <span>The golem's weapon attacks are magical.</span>
                </div>
                <br/>
                
            </div>
        </div>
        
        
            <div id="actions">
                <div class="creature-heading">
                    <h1>Actions</h1>
                </div>
                <div>
                    
                        <div>
                            <b>Multiattack: </b>
                            <span>The golem makes two slam attacks.</span>
                        </div>
                        <br/>
                        
                        <div>
                            <b>Slam: </b>
                            <span>Melee Weapon Attack: <a class='roll'>+7</a> to hit, reach 5 ft., one target. 13 <a class='roll'>(2d8 + 4)</a> bludgeoning damage.</span>
                        </div>
                        <br/>
                        
                        <br/>
                    </div>
                </div>
                
                
                        

      <div id="reactions">
        <div class="creature-heading">
          <h1>
              Description
          </h1>
        </div>
        <p>A flesh golem is a grisly assortment of humanoid body parts stitched and bolted together into a muscled brute imbued with formidable strength. Its brain is capable of simple reason, though its thoughts are no more sophisticated than those of a young child. The golem's muscle tissue responds to the power of lightning, invigorating the creature with vitality and strength. Powerful enchantments protect the golem's skin, deflecting spells and all but the most potent weapons.
A flesh golem lurches with a stiff-jointed gait, as if not in complete control of its body. Its dead flesh isn't an ideal container for an elemental spirit, which sometimes howls incoherently to vent its outrage. If the spirit breaks free of its creator's will, the golem goes berserk until calmed, or until its shell of flesh is destroyed or completely healed.
Golems. Golems are made from humble materials-clay, flesh and bones, iron, or stone-but they possess astonishing power and durability. A golem has no ambitions, needs no sustenance, feels no pain, and knows no remorse. An unstoppable juggernaut, it exists to follow its creator's orders, and it protects or attacks as that creator demands.
To create a golem, one requires a manual of golems (see the Dungeon Master's Guide). The comprehensive illustrations and instructions in a manual detail the process for creating a golem of a particular type.
Elemental Spirit in Material Form.  The construction of a golem begins with the building of its body, requiring great command of the craft of sculpting, stonecutting, ironworking, or surgery. Sometimes a golem's creator is the master of the art, but often the individual who desires a golem must enlist master artisans to do the work.
After constructing the body from clay, flesh, iron, or stone, the golem's creator infuses it with a spirit from the Elemental Plane of Earth. This tiny spark of life has no memory, personality, or history. It is simply the impetus to move and obey. This process binds the spirit to the artificial body and subjects it to the will of the golem's creator.
A golem can be created with a special amulet or other item that allows the possessor of the item to control the golem. Golems whose creators are long dead can thus be harnessed to serve a new master.
A golem can't think or act for itself. Though it understands its commands perfectly, it has no grasp of language beyond that understanding, and can't be reasoned with or tricked with words.
Ageless Guardians.  Golems can guard sacred sites, tombs, and treasure vaults long after the deaths of their creators, carrying out their appointed tasks for all eternity while brushing off physical damage and ignoring all but the most potent spells.
Blind Obedience. When its creator or possessor is on hand to command it, a golem performs flawlessly. If the golem is left without instructions or is incapacitated, it continues to follow its last orders to the best of its ability. When it can't fulfill its orders, a golem might react violently-or stand and do nothing. A golem that has been given conflicting orders sometimes alternates between them.
Constructed Nature.  A golem doesn't require air, food, drink, or sleep.
Source: Monster Manual p. 169, Curse of Strahd, Rise of Tiamat, Tales from the Yawning Portal, Tomb of Annihilation, Waterdeep: Dragon Heist, Waterdeep: Dungeon of the Mad Mage, Ghosts of Saltmarsh, Essentials Kit: Dragon of Icespire Peak, Essentials Kit: Sleeping Dragon's Wake, Explorer's Guide to Wildemount, Mythic Odysseys of Theros, Icewind Dale: Rime of the Frostmaiden</p>
      </div>
      <hr class="orange-border bottom"/>
    </div>
  </div>
</div>
    </body>
    <script>

    function findToHit(dataString) {
        const pattern = /\+(\d{1,2}) to hit/
        let match = dataString.match(pattern)
        if (match !== null) {
            match = match[1]
        }
        return {
            "exists": match !== null,
            "value": parseInt(match)
        }
    }

    function findDamageStrings(dataString) {
        if (typeof dataString === "string") {
            let damageStrings = []
            // const toHitPattern = /\+(\d{1,2}) to hit/
            const toHitPattern = /\+(\d{1,2})/g
            const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/g
            let damageMatches = dataString.matchAll(damagePattern)
            let toHitMatches = dataString.matchAll(toHitPattern)
            for (let match of toHitMatches) {
                if (toHitMatches !== null) {
                    damageStrings.push(match[0])
                }
            }
            for (let match of damageMatches) {
                if (match !== null) {
                    damageStrings.push(match[0])
                }
            }
            return damageStrings
        }
        return []
    }

    function extractRoll(dataString) {
        const damagePattern = /\(*(\d{1,2})d(\d{1,2})\s?\+?\s?(\d{0,2})\)*/
        const toHitPattern = /\+(\d{1,2})/
        let damageMatch = dataString.match(damagePattern)
        let toHitMatch = dataString.match(toHitPattern)
        if (toHitMatch !== null) {
            return {"num": 1, "sides": 20, "mod": toHitMatch[1]}
        }
        if (damageMatch !== null) {
            return {"num": damageMatch[1], "sides": damageMatch[2], "mod": damageMatch[3]}
        }
    }

    function randomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + 1);
    }

    function generateRollText(num, sides, mod) {
        let output = []
        let total = 0
        for (let i = 0; i < num; i++) {
            let roll = randomNumber(1, sides)
            total += roll
            output.push(roll)
            output.push("+")
        }
        output.pop()
        if (mod >= 0 && mod !== "") {
            output.push("+")
            output.push(`(${mod})`)
            total += parseInt(mod) || 0
        } else {
            if (mod !== "") {
                output.push("+")
                output.push(`(${mod})`)
                total += parseInt(mod) || 0
            }
        }
        output.push(` = ${total}`)
        return output.join(" ")
    }

    function splitAroundRoll(dataString, patternMatches) {
        let outPut = []
        let currentPosition = 0
        for (let match of patternMatches) {
            let matchLength = match.length
            let matchStartingPosition = dataString.indexOf(match, currentPosition)
            let matchEndingPosition = matchStartingPosition + matchLength
            outPut.push({
                "value": dataString.slice(currentPosition, matchStartingPosition),
                "replace": false
            })
            currentPosition = matchEndingPosition
            outPut.push({"value": match, "replace": true})
        }
        outPut.push({"value": dataString.slice(currentPosition), "replace": false})
        return outPut;
    }

    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }

    function findSpells(traitText, spell_list) {
        let outPutList = [];
        let wordArray = traitText.split(",")
        for (let word of wordArray) {
            if (word.includes(":")) {
                word = word.slice(word.indexOf(":") + 1)
            }
            if (spell_list.includes(word.trim())) {
                outPutList.push(word)
            }
        }
        return outPutList
    }

    function addSpellIds(chunks, spell_list) {
        for (let chunk of chunks) {
            if (chunk.replace) {
                if (chunk.value.includes(":")) {
                    chunk.value = chunk
                        .value
                        .slice(chunk.value.indexOf(":") + 1)
                }
                chunk["spellId"] = spell_list.indexOf(chunk.value.trim())
            }
        }
        return chunks
    }

    document.addEventListener('DOMContentLoaded', () => {
        document
            .querySelectorAll('.roll')
            .forEach(element => {
                element.addEventListener('click', () => {
                    let roll = extractRoll(element.textContent)
                    let rollText = generateRollText(roll.num, roll.sides, roll.mod);
                    Toastify({
                        text: rollText,
                        duration: 1000,
                        gravity: "bottom", // `top` or `bottom`
                        position: "center", // `left`, `center` or `right`
                        stopOnFocus: true, // Prevents dismissing of toast on hover
                    }).showToast();

                    console.log(rollText)
                });
            });
    });
    (function (root, factory) {
        if (typeof module === "object" && module.exports) {
            module.exports = factory();
        } else {
            root.Toastify = factory();
        }
    })(this, function (global) {
        // Object initialization
        var Toastify = function (options) {
                // Returning a new init object
                return new Toastify
                    .lib
                    .init(options);
            },
            // Library version
            version = "1.12.0";

        // Set the default global options
        Toastify.defaults = {
            oldestFirst: true,
            text: "Toastify is awesome!",
            node: undefined,
            duration: 3000,
            selector: undefined,
            callback: function () {},
            destination: undefined,
            newWindow: false,
            close: false,
            gravity: "toastify-top",
            positionLeft: false,
            position: '',
            backgroundColor: '',
            avatar: "",
            className: "",
            stopOnFocus: true,
            onClick: function () {},
            offset: {
                x: 0,
                y: 0
            },
            escapeMarkup: true,
            ariaLive: 'polite',
            style: {
                background: ''
            }
        };

        // Defining the prototype of the object
        Toastify.lib = Toastify.prototype = {
            toastify: version,

            constructor: Toastify,

            // Initializing the object with required parameters
            init: function (options) {
                // Verifying and validating the input object
                if (!options) {
                    options = {};
                }

                // Creating the options object
                this.options = {};

                this.toastElement = null;

                // Validating the options
                this.options.text = options.text || Toastify.defaults.text; // Display message
                this.options.node = options.node || Toastify.defaults.node; // Display content as node
                this.options.duration = options.duration === 0
                    ? 0
                    : options.duration || Toastify.defaults.duration; // Display duration
                this.options.selector = options.selector || Toastify.defaults.selector; // Parent selector
                this.options.callback = options.callback || Toastify.defaults.callback; // Callback after display
                this.options.destination = options.destination || Toastify.defaults.destination; // On-click destination
                this.options.newWindow = options.newWindow || Toastify.defaults.newWindow; // Open destination in new window
                this.options.close = options.close || Toastify.defaults.close; // Show toast close icon
                this.options.gravity = options.gravity === "bottom"
                    ? "toastify-bottom"
                    : Toastify.defaults.gravity; // toast position - top or bottom
                this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft; // toast position - left or right
                this.options.position = options.position || Toastify.defaults.position; // toast position - left or right
                this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor; // toast background color
                this.options.avatar = options.avatar || Toastify.defaults.avatar; // img element src - url or a path
                this.options.className = options.className || Toastify.defaults.className; // additional class names for the toast
                this.options.stopOnFocus = options.stopOnFocus === undefined
                    ? Toastify.defaults.stopOnFocus
                    : options.stopOnFocus; // stop timeout on focus
                this.options.onClick = options.onClick || Toastify.defaults.onClick; // Callback after click
                this.options.offset = options.offset || Toastify.defaults.offset; // toast offset
                this.options.escapeMarkup = options.escapeMarkup !== undefined
                    ? options.escapeMarkup
                    : Toastify.defaults.escapeMarkup;
                this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
                this.options.style = options.style || Toastify.defaults.style;
                if (options.backgroundColor) {
                    this.options.style.background = options.backgroundColor;
                }

                // Returning the current object for chaining functions
                return this;
            },

            // Building the DOM element
            buildToast: function () {
                // Validating if the options are defined
                if (!this.options) {
                    throw "Toastify is not initialized";
                }

                // Creating the DOM object
                var divElement = document.createElement("div");
                divElement.className = "toastify on " + this.options.className;

                // Positioning toast to left or right or center
                if (!!this.options.position) {
                    divElement.className += " toastify-" + this.options.position;
                } else {
                    // To be depreciated in further versions
                    if (this.options.positionLeft === true) {
                        divElement.className += " toastify-left";
                        console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.')
                    } else {
                        // Default position
                        divElement.className += " toastify-right";
                    }
                }

                // Assigning gravity of element
                divElement.className += " " + this.options.gravity;

                if (this.options.backgroundColor) {
                    // This is being deprecated in favor of using the style HTML DOM property
                    console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
                }

                // Loop through our style object and apply styles to divElement
                for (var property in this.options.style) {
                    divElement.style[property] = this
                        .options
                        .style[property];
                }

                // Announce the toast to screen readers
                if (this.options.ariaLive) {
                    divElement.setAttribute('aria-live', this.options.ariaLive)
                }

                // Adding the toast message/node
                if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
                    // If we have a valid node, we insert it
                    divElement.appendChild(this.options.node)
                } else {
                    if (this.options.escapeMarkup) {
                        divElement.innerText = this.options.text;
                    } else {
                        divElement.innerHTML = this.options.text;
                    }

                    if (this.options.avatar !== "") {
                        var avatarElement = document.createElement("img");
                        avatarElement.src = this.options.avatar;

                        avatarElement.className = "toastify-avatar";

                        if (this.options.position == "left" || this.options.positionLeft === true) {
                            // Adding close icon on the left of content
                            divElement.appendChild(avatarElement);
                        } else {
                            // Adding close icon on the right of content
                            divElement.insertAdjacentElement("afterbegin", avatarElement);
                        }
                    }
                }

                // Adding a close icon to the toast
                if (this.options.close === true) {
                    // Create a span for close element
                    var closeElement = document.createElement("button");
                    closeElement.type = "button";
                    closeElement.setAttribute("aria-label", "Close");
                    closeElement.className = "toast-close";
                    closeElement.innerHTML = "&#10006;";

                    // Triggering the removal of toast from DOM on close click
                    closeElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this.removeElement(this.toastElement);
                        window.clearTimeout(this.toastElement.timeOutValue);
                    }.bind(this));

                    //Calculating screen width
                    var width = window.innerWidth > 0
                        ? window.innerWidth
                        : screen.width;

                    // Adding the close icon to the toast element
                    // Display on the right if screen width is less than or equal to 360px
                    if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
                        // Adding close icon on the left of content
                        divElement.insertAdjacentElement("afterbegin", closeElement);
                    } else {
                        // Adding close icon on the right of content
                        divElement.appendChild(closeElement);
                    }
                }

                // Clear timeout while toast is focused
                if (this.options.stopOnFocus && this.options.duration > 0) {
                    var self = this;
                    // stop countdown
                    divElement.addEventListener("mouseover", function (event) {
                        window.clearTimeout(divElement.timeOutValue);
                    })
                    // add back the timeout
                    divElement.addEventListener("mouseleave", function () {
                        divElement.timeOutValue = window.setTimeout(function () {
                            // Remove the toast from DOM
                            self.removeElement(divElement);
                        }, self.options.duration)
                    })
                }

                // Adding an on-click destination path
                if (typeof this.options.destination !== "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        if (this.options.newWindow === true) {
                            window.open(this.options.destination, "_blank");
                        } else {
                            window.location = this.options.destination;
                        }
                    }.bind(this));
                }

                if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
                    divElement.addEventListener("click", function (event) {
                        event.stopPropagation();
                        this
                            .options
                            .onClick();
                    }.bind(this));
                }

                // Adding offset
                if (typeof this.options.offset === "object") {

                    var x = getAxisOffsetAValue("x", this.options);
                    var y = getAxisOffsetAValue("y", this.options);

                    var xOffset = this.options.position == "left"
                        ? x
                        : "-" + x;
                    var yOffset = this.options.gravity == "toastify-top"
                        ? y
                        : "-" + y;

                    divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";

                }

                // Returning the generated element
                return divElement;
            },

            // Displaying the toast
            showToast: function () {
                // Creating the DOM object for the toast
                this.toastElement = this.buildToast();

                // Getting the root element to with the toast needs to be added
                var rootElement;
                if (typeof this.options.selector === "string") {
                    rootElement = document.getElementById(this.options.selector);
                } else if (this.options.selector instanceof HTMLElement || (typeof ShadowRoot !== 'undefined' && this.options.selector instanceof ShadowRoot)) {
                    rootElement = this.options.selector;
                } else {
                    rootElement = document.body;
                }

                // Validating if root element is present in DOM
                if (!rootElement) {
                    throw "Root element is not defined";
                }

                // Adding the DOM element
                var elementToInsert = Toastify.defaults.oldestFirst
                    ? rootElement.firstChild
                    : rootElement.lastChild;
                rootElement.insertBefore(this.toastElement, elementToInsert);

                // Repositioning the toasts in case multiple toasts are present
                Toastify.reposition();

                if (this.options.duration > 0) {
                    this.toastElement.timeOutValue = window.setTimeout(function () {
                        // Remove the toast from DOM
                        this.removeElement(this.toastElement);
                    }.bind(this), this.options.duration); // Binding `this` for function invocation
                }

                // Supporting function chaining
                return this;
            },

            hideToast: function () {
                if (this.toastElement.timeOutValue) {
                    clearTimeout(this.toastElement.timeOutValue);
                }
                this.removeElement(this.toastElement);
            },

            // Removing the element from the DOM
            removeElement: function (toastElement) {
                // Hiding the element
                // toastElement.classList.remove("on");
                toastElement.className = toastElement
                    .className
                    .replace(" on", "");

                // Removing the element from DOM after transition end
                window.setTimeout(function () {
                    // remove options node if any
                    if (this.options.node && this.options.node.parentNode) {
                        this
                            .options
                            .node
                            .parentNode
                            .removeChild(this.options.node);
                    }

                    // Remove the element from the DOM, only when the parent node was not removed before.
                    if (toastElement.parentNode) {
                        toastElement
                            .parentNode
                            .removeChild(toastElement);
                    }

                    // Calling the callback function
                    this
                        .options
                        .callback
                        .call(toastElement);

                    // Repositioning the toasts again
                    Toastify.reposition();
                }.bind(this), 400); // Binding `this` for function invocation
            }
        };

        // Positioning the toasts on the DOM
        Toastify.reposition = function () {

            // Top margins with gravity
            var topLeftOffsetSize = {
                top: 15,
                bottom: 15
            };
            var topRightOffsetSize = {
                top: 15,
                bottom: 15
            };
            var offsetSize = {
                top: 15,
                bottom: 15
            };

            // Get all toast messages on the DOM
            var allToasts = document.getElementsByClassName("toastify");

            var classUsed;

            // Modifying the position of each toast element
            for (var i = 0; i < allToasts.length; i++) {
                // Getting the applied gravity
                if (containsClass(allToasts[i], "toastify-top") === true) {
                    classUsed = "toastify-top";
                } else {
                    classUsed = "toastify-bottom";
                }

                var height = allToasts[i].offsetHeight;
                classUsed = classUsed.substr(9, classUsed.length - 1)
                // Spacing between toasts
                var offset = 15;

                var width = window.innerWidth > 0
                    ? window.innerWidth
                    : screen.width;

                // Show toast in center if screen with less than or equal to 360px
                if (width <= 360) {
                    // Setting the position
                    allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";

                    offsetSize[classUsed] += height + offset;
                } else {
                    if (containsClass(allToasts[i], "toastify-left") === true) {
                        // Setting the position
                        allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";

                        topLeftOffsetSize[classUsed] += height + offset;
                    } else {
                        // Setting the position
                        allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";

                        topRightOffsetSize[classUsed] += height + offset;
                    }
                }
            }

            // Supporting function chaining
            return this;
        };

        // Helper function to get offset.
        function getAxisOffsetAValue(axis, options) {

            if (options.offset[axis]) {
                if (isNaN(options.offset[axis])) {
                    return options.offset[axis];
                } else {
                    return options.offset[axis] + 'px';
                }
            }

            return '0px';

        }

        function containsClass(elem, yourClass) {
            if (!elem || typeof yourClass !== "string") {
                return false;
            } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
                return true;
            } else {
                return false;
            }
        }

        // Setting up the prototype for the init object
        Toastify.lib.init.prototype = Toastify.lib;

        // Returning the Toastify function to be assigned to the window object/module
        return Toastify;
    });
</script>
    <style>
  :root {
    --base-font-family: "Calluna", Georgia, serif;
    --base-font-size: 18px;
    --small-font-size: var(--base-font-size) * 0.875;
    --base-line-height: 1.5;
    --spacing-unit: 30px;
    --spacing-unit-line: 7px;
    --text-color: #181818;
    --background-color: #fdfdfd;
    --brand-color: #4d96b9;
    --brand-color-secondary: #109269;
    --brand-color-light: lighten(var(--brand-color-secondary), 1%);
    --brand-color-dark: darken(var(--brand-color-secondary), 1%);
    --grey-color: #141414;
    --grey-color-light: lighten(var(--grey-color), 20%);
    --grey-color-dark: darken(var(--grey-color), 15%);
    --on-palm: 750px;
    --on-laptop: 800px;
    --statblock-main-color: #7a200d;
    --statblock-secondary-color: #922610;
    --statblock-background-color: #fdf1dc;
    --toastContainerTop: auto;
    --toastContainerRight: auto;
    --toastContainerBottom: 8rem;
    --toastContainerLeft: calc(50vw - 8rem);
  }

  a {
    color: blue;
    cursor: pointer;
  }

  .stat-header {
    margin-bottom: 1em;
    margin-top: 1em;
  }
  .stat-value {
    font-size: 20px;
  }

  .stat-block {
    font-size: 13.5px;
    line-height: 1.2em;
    box-sizing: border-box;
    max-width: 100%;
    text-align: left;
    vertical-align: top;
    width: 50%;
    min-width: 280px;
    background: var(--statblock-background-color);
    padding: 5px 10px 20px;
    box-shadow: 0 0 1.5em #867453;
    margin-top: 20px;
    margin-bottom: 10px;
    margin-right: auto;
    margin-left: auto;
  }
  .stat-block p {
    margin-bottom: 10px;
  }
  .stat-block h4 {
    font-weight: bold;
  }
  .orange-border {
    display: block;
    background: #e69a28;
    border: 1px solid #000;
    height: 5px;
    padding: 0 10px 0;
    margin: -10px -10px 0;
    box-sizing: initial;
  }
  .orange-border.bottom {
    margin: 15px -10px -20px;
  }
  .tapered-rule {
    display: block;
    width: 100%;
    height: 5px;
    border: none;
    color: var(--statblock-secondary-color);
    fill: var(--statblock-secondary-color);
    stroke: var(--statblock-secondary-color);
  }
  .top-gap {
    margin: 0 0 8px;
  }
  .bottom-gap {
    margin: 10px 0;
  }
  .creature-heading h1 {
    color: var(--statblock-secondary-color);
    font-size: 23px;
    line-height: 1.2em;
    margin: 10px 0 0;
    letter-spacing: 1px;
    font-variant: small-caps;
    font-weight: bold;
  }
  .creature-heading h2 {
    font-weight: normal;
    font-style: italic;
    font-size: 12px;
    line-height: 1.2em;
    margin: 0 0 10px;
  }
  .property-line h4,
  .property-line p {
    display: inline;
    margin: 0;
    color: var(--statblock-secondary-color);
    font-size: 13.5px;
    line-height: 1.2em;
  }
  .property-line h4 {
    color: var(--statblock-main-color);
  }
  .property-line {
    text-indent: -1em;
    padding-left: 1.1em;
    line-height: 1.4em;
  }
  .property-line.first {
    margin: 8px 0 0;
  }
  .property-line.last {
    margin: 0 0 10px;
  }
  .abilities {
    text-align: center;
    color: var(--statblock-secondary-color);
    margin-bottom: 1em;
  }
  .abilities > div {
    display: inline-block;
    vertical-align: middle;
    width: 12.5%;
    min-width: 40px;
    font-size: 12px;
    line-height: 1em;
  }
  #actions > *,
  #reactions > * {
    border-bottom: 1px solid var(--statblock-main-color);
    color: var(--statblock-main-color);
    font-size: 14px;
    font-weight: normal;
    margin: 10px 0 0;
    padding: 0 0 10px;
    text-indent: 5px;
  }
  #actions,
  #reactions {
    margin: 0 0 10px;
  }
  #actions:last-child,
  #reactions:last-child {
    margin: 0;
  }

  @media print {
    .orange-border {
      display: none;
    }
    .stat-block,
    .property-line,
    .stat-block {
      width: 40%;
      display: inline-block;
      vertical-align: top;
    }
  }
  @media screen and (max-width: 575px) {
    .stat-block {
      /* margin: 5px; */
      width: 100%;
    }
  }

.toastify {
    padding: 12px 20px;
    color: #ffffff;
    display: inline-block;
    box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);
    background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);
    background: linear-gradient(135deg, #73a5ff, #5477f5);
    position: fixed;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
    border-radius: 2px;
    cursor: pointer;
    text-decoration: none;
    max-width: calc(50% - 20px);
    z-index: 2147483647;
}

.toastify.on {
    opacity: 1;
}

.toast-close {
    background: transparent;
    border: 0;
    color: white;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    opacity: 0.4;
    padding: 0 5px;
}

.toastify-right {
    right: 15px;
}

.toastify-left {
    left: 15px;
}

.toastify-top {
    top: -150px;
}

.toastify-bottom {
    bottom: -150px;
}

.toastify-rounded {
    border-radius: 25px;
}

.toastify-avatar {
    width: 1.5em;
    height: 1.5em;
    margin: -7px 5px;
    border-radius: 2px;
}

.toastify-center {
    margin-left: auto;
    margin-right: auto;
    left: 0;
    right: 0;
    max-width: fit-content;
    max-width: -moz-fit-content;
}

@media only screen and (max-width: 360px) {
    .toastify-right, .toastify-left {
        margin-left: auto;
        margin-right: auto;
        left: 0;
        right: 0;
        max-width: fit-content;
    }
}
</style>

</html>